<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>JSDoc: TypeScript inside JavaScript and not the other way around ü§Ø</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>document.documentElement.classList.add(localStorage.theme || ((matchMedia && matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light'))</script>
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/github-20220617.css">
  <link rel="stylesheet" href="/css/main-20250606.css">
  <link rel="icon" href="/favicon.ico" data-emoji="üèïÔ∏è">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="CodeJam">
  <meta property="og:title" content="JSDoc: TypeScript inside JavaScript and not the other way around ü§Ø">
  <meta property="og:description" content="This post is inspired by this great Speakeasy JS talk by Austin Gil. üíØ">
  <meta property="og:image" content="https://www.codejam.info/img/profile.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@valeriangalliat">
  <meta name="twitter:creator" content="@valeriangalliat">
</head>
<body class="post">
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/val.html">About</a></li>
      <li><a href="/now.html">Now</a></li>
      <li class="pull"><button title="Toggle theme" class="change-color-theme">üåù</button></li>
    </ul>
  </nav>
  <header>
    <div class="header-inner">
      <div class="content">
<h1>JSDoc: TypeScript inside JavaScript and not the other way around ü§Ø</h1>
<p class="date">October 17, 2021</p>
      </div>
    </div>
  </header>
  <div class="content">
<p>This post is inspired by this great <a href="https://speakeasyjs.com/">Speakeasy JS</a>
talk by <a href="https://austingil.com/">Austin Gil</a>. üíØ</p>
<figure class="video">
  <iframe src="https://www.youtube.com/embed/iP5XwRT2tNw" allowfullscreen></iframe>
</figure>
<p>Even though I was familiar with the concept of type checking JS files
with TypeScript through JSDoc, I‚Äôve always seen it as a way to
<strong>transition to TypeScript</strong>. You would progressively add
TypeScript-compatible JSDoc to an existing JavaScript project until
everything is covered, to ultimately transition to the actual TypeScript
syntax.</p>
<p>But it never crossed my mind to use TypeScript with JSDoc as an end
goal. Until I saw that talk.</p>
<h2 id="the-problem-with-compiled-javascript" tabindex="-1"><a class="header-anchor" href="#the-problem-with-compiled-javascript"><span>The problem with compiled JavaScript</span></a></h2>
<p>The main reason I don‚Äôt use TypeScript is not because of TypeScript
itself (even though there‚Äôs a lot to say here). It‚Äôs because I don‚Äôt
like to compile my JavaScript in the first place, at least not when it‚Äôs
intended for Node.js.</p>
<p>It‚Äôs the same reason I don‚Äôt use <a href="https://flow.org/">Flow</a>,
<a href="https://elm-lang.org/">Elm</a>, <a href="https://dart.dev/">Dart</a>,
<a href="https://babeljs.io/">Babel</a> or <a href="https://coffeescript.org/">CoffeeScript</a>.</p>
<p>JavaScript being an interpreted language, it naturally comes with the
ability to directly run your code. <strong>This is an incredibly convenient
thing.</strong></p>
<ul>
<li>It‚Äôs fast as fuck because there‚Äôs nothing to compile.</li>
<li>You can inspect and debug directly what you write without any extra
tool or configuration.</li>
<li>Your stack traces will be readable and usable out of the box.</li>
<li>Every tool and service you use will (mostly) understand your code by
default, because it‚Äôs <em>native</em> and doesn‚Äôt require special treatment.</li>
</ul>
<p>That‚Äôs a lot of time saved right there by not having to maintain custom
configurations on all the tools and services you use, on top of the fact
you need to install, configure, update and maintain a number of extra
tools, pipelines, workflows, which you‚Äôll also need to teach to
everybody who‚Äôs going to work with you because we all do those things a
little bit differently.</p>
<p>Now, there are benefits to invest in this extra work, so if the cost of
compiling your JavaScript is worth it for you, or you just enjoy the
process, that‚Äôs fine! As far as I‚Äôm concerned, I don‚Äôt enjoy a single
bit of it.</p>
<h2 id="separate-type-definitions-hell" tabindex="-1"><a class="header-anchor" href="#separate-type-definitions-hell"><span>Separate type definitions hell üî•</span></a></h2>
<p>Static types are useful and there‚Äôs no argument that having type
checking is generally a beneficial thing. For that reason, more and more
people want types with the libraries they‚Äôre going to use.</p>
<p>I maintain <a href="https://github.com/valeriangalliat">quite a few</a> open-source
JavaScript libraries, and on the most popular ones, people have
requested (or better, contributed) TypeScript definitions, whether it‚Äôs
directly in the package repository or on <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">Definitely Typed</a>.</p>
<p>While this comes from a good intention, it causes a number of issues for
everybody involved:</p>
<ul>
<li>
<p>When added directly to the package repository, types represent extra
work for the maintainers who initially wrote a JavaScript project and
didn‚Äôt want to write, maintain, and deal with a TypeScript project.</p>
</li>
<li>
<p>Types are pretty much always added as manually written, static <code>.d.ts</code>
files, because it would represent a lot more work (on top of being
extremely bold and opinionated) to convert the project to TypeScript,
and nobody really wants to do that.</p>
<p>This means there‚Äôs no guarantee that the types will match what the JS
code is actually doing. It‚Äôs a best effort that worked good enough for
whoever contributed it.</p>
</li>
<li>
<p>On top of that, the maintainers (e.g. me) might ‚Äúforget‚Äù to update the
previously contributed TypeScript definitions when they make changes.
The more changes there is, the more likely the types won‚Äôt be updated
because of the amount of extra work it represents.</p>
<p>This means that the included types will most certainly drift out of
sync with the actual code (even more than they already are) until it
breaks someone‚Äôs build and they contribute a fix.</p>
</li>
</ul>
<p>As a maintainer, what can I do?</p>
<ul>
<li>Should I reject a PR that add type definitions because I‚Äôm not ready
to commit to the extra work required to maintain them?</li>
<li>Should I merge the PR only at the condition that the person becomes a
core contributor and maintain the types in future updates?</li>
<li>Should I merge the PR but put a note somewhere that types are
community contributed and might drift out of sync from the JavaScript
code, a bit like I do for translations contributed in languages that I
don‚Äôt speak?</li>
</ul>
<p>I don‚Äôt like any of those choices. Luckily, most of my projects are
small enough that the types don‚Äôt represent a lot of extra work, plus
everybody seems to be happy with type definitions covering only the
happy path which is usually a small subset of the codebase.</p>
<p>So for now I just merge the PRs and let TypeScript users contribute
improvements and bug fixes over time as they need them. It seems that
they‚Äôre used to having things partially broken all the time and they
prefer to have inaccurate or incomplete types than no types.</p>
<h2 id="having-the-best-of-both-worlds" tabindex="-1"><a class="header-anchor" href="#having-the-best-of-both-worlds"><span>Having the best of both worlds</span></a></h2>
<p>Out of sympathy for those users (I truly think they deserve something
better), and also because I do believe in the benefits of static typing
(as much as I hate compiling an interpreted language), I decided to
start my <a href="https://github.com/valeriangalliat/node-firefox-sync">latest JavaScript library</a>
with TypeScript definitions in mind from the start.</p>
<p>Thanks to the talk I shared in the beginning of this post, I decided to
write my JSDoc comments in a way that the TypeScript compiler can
consume. Here‚Äôs a few examples:</p>
<details>
  <summary><a href="https://github.com/valeriangalliat/node-firefox-sync/blob/master/auth/oauth.js"><code>auth/oauth.js</code></a></summary>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)
<span class="hljs-keyword">const</span> base = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./oauth-base&#x27;</span>)

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">SyncOAuthChallengeImpl</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">crypto.KeyPairKeyObjectResult</span>} <span class="hljs-variable">keyPair</span>
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">base.OAuthChallenge &amp; SyncOAuthChallengeImpl</span>} <span class="hljs-variable">SyncOAuthChallenge</span>
 */</span>

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">SyncOAuthChallenge</span>} <span class="hljs-variable">challenge</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">base.OAuthResult</span>} <span class="hljs-variable">result</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} [options]
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} [options.clientId] - OAuth client ID.
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} [options.scope] - OAuth scope.
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} [options.tokenEndpoint] - OAuth token endpoint.
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} [options.tokenServerUrl] - TokenServer URL.
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;import(&#x27;../types&#x27;).SyncCredentials&gt;</span>}
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">complete</span> (<span class="hljs-params">challenge, result, options</span>) {
  <span class="hljs-comment">// Actual code.</span>
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = { complete }
</code></pre>
</details>
<details>
  <summary><a href="https://github.com/valeriangalliat/node-firefox-sync/blob/master/types.js"><code>types.js</code></a></summary>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">SyncOptions</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} [authServerUrl]
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} [authorizationUrl]
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} [tokenEndpoint]
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} [tokenServerUrl]
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">import(&#x27;./auth/oauth-base&#x27;).OAuthOptions</span>} [oauthOptions]
 *
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">OAuthToken</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">access_token</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">scope</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">expires_in</span>
 *
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">SyncToken</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">id</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">key</span>
 *
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">SyncKeyBundle</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">encryptionKey</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">hmacKey</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">kid</span>
 *
 * <span class="hljs-doctag">@typedef</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">SyncCredentials</span>
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">OAuthToken</span>} <span class="hljs-variable">oauthToken</span> - The OAuth token required to authenticate to the TokenServer.
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">SyncKeyBundle</span>} <span class="hljs-variable">syncKeyBundle</span> - The Sync key bundle required to decrypt the collection keys.
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">SyncToken</span>} <span class="hljs-variable">token</span> - The token object required to call the Firefox Sync API.
 * <span class="hljs-doctag">@property</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">tokenIssuedAt</span> - Timestamp in milliseconds of when the token was issued to preemptively refresh it.
 */</span>

<span class="hljs-comment">// Does nothing but required for TypeScript to import this file.</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {}
</code></pre>
</details>
<p>Because I was writing that library from scratch and not adding types to
an existing project, this came at a lower cost, and yielded two major
benefits:</p>
<ul>
<li>I can leverage TypeScript for type checking even though the code is
pure JavaScript.</li>
<li>I can let TypeScript derivate <strong>accurate</strong> type definitions from the
source code.</li>
</ul>
<p>Since the <code>.d.ts</code> files are automatically generated as opposed to being
manually maintained, this drastically reduces the chance for them to go
out of sync or be inaccurate, especially because the code itself is also
type checked (this is important because TypeScript will otherwise
happily generate totally broken type definitions from JSDoc comments
that don‚Äôt pass type checking).</p>
<p>Also for that same reason, if the types were to be incomplete (there‚Äôs
still a number of <code>any</code> in this project, I admit), contributors will
have to add them as JSDoc comments to the JavaScript source and not just
to a ‚Äúdead‚Äù <code>.d.ts</code> file, making the code safer as a side effect by
increasing the actual type checking coverage, and guaranteeing that the
exported types match the underlying implementation. Not only this tests
code against the types, but as importantly, <strong>it tests the types against
the code</strong>.</p>
<h2 id="why-this-works-best-for-me" tabindex="-1"><a class="header-anchor" href="#why-this-works-best-for-me"><span>Why this works best for me</span></a></h2>
<p>With this pattern, I can still <strong>write, run and debug native JavaScript
code</strong>.</p>
<p>This is what makes me <strong>efficient at what I‚Äôm doing</strong>. My development is
not slowed down by constantly running a compiler, dealing with the extra
complexity that comes with debugging transpiled code, and time spent
fixing type errors on non-production code.</p>
<p>When I write a piece of code, it‚Äôs rarely going to be perfect,
production quality code from the start. It takes me dozens of iterations
and rewriting pieces of it until I reach a point where I‚Äôm satisfied.
Only when I‚Äôm done I‚Äôll clean up and refactor whatever parts need extra
love, handle the edge cases, and make the linter happy. This is when,
and only when, I want to run the type checks. There‚Äôs no point in having
blocking type checks on code that I‚Äôll rewrite or remove a minute later.</p>
<div class="note">
<p><strong>Note:</strong> this last point is a problem that I had specifically with the
<code>ts-node</code> utility, but <code>tsc</code> itself is more forgiving and will output a
runnable JS code even when there‚Äôs type errors.</p>
<p>Also while writing this section, I stumbled upon <code>ts-node --transpile-only</code>
that allows running the code even if it doesn‚Äôt pass type validation,
which seems like a must-have during development. I‚Äôm kinda sour that
it took me a 4 months post-burnout retirement kind of step back to
finally find about it, after fighting with this problem for years. üò¨</p>
</div>
<h2 id="the-chicken-and-egg-problem-between-js-and-d-ts" tabindex="-1"><a class="header-anchor" href="#the-chicken-and-egg-problem-between-js-and-d-ts"><span>The chicken and egg problem between <code>.js</code> and <code>.d.ts</code></span></a></h2>
<p>I didn‚Äôt share the commands I use to do the type checking and derive the
<code>.d.ts</code> files from the JSDoc comments yet, and you‚Äôre probably dying to
know them. üòâ</p>
<p>But first, I need to share something else with you. See, I usually have
this kind of structure for packages I publish on npm:</p>
<pre><code class="hljs">my-cool-package
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ test.js
</code></pre>
<p>It seems that the natural way to <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html#tsconfig">extract type definitions</a>
would be:</p>
<pre><code class="hljs language-sh">tsc *.js --allowJs --declaration --emitDeclarationOnly
</code></pre>
<p>Which yields:</p>
<pre><code class="hljs">my-cool-package
‚îú‚îÄ‚îÄ <span class="hljs-addition">index.d.ts</span>
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ <span class="hljs-addition">test.d.ts</span>
‚îî‚îÄ‚îÄ test.js</code></pre>
<p>You‚Äôll quickly notice that there‚Äôs something funky with this method of
doing things.</p>
<ul>
<li>We generate <code>.d.ts</code> files from <code>.js</code> files.</li>
<li>TypeScript has an <strong>hardcoded</strong> rule where it systematically imports
any <code>.d.ts</code> file that‚Äôs next to an imported <code>.js</code> file. This is
regardless of your explicit <code>include</code> and <code>exclude</code> patterns and
there‚Äôs no way to turn off this behavior.</li>
<li>TypeScript refuses to overwrite input files (and that‚Äôs a good thing).</li>
</ul>
<p>But guess what? <code>test.js</code> imports <code>index.js</code> (so that it can, you know,
test it).</p>
<p>The problem here is that while this command will run fine the first
time, <a href="https://github.com/microsoft/TypeScript/issues/16749">subsequent runs will fail</a>
because TypeScript will <em>always</em> consider a <code>.d.ts</code> that is next to an
included <code>.js</code> file to be part of its inputs and will refuse to
overwrite it. And even if it allowed to overwrite the declaration files,
we would still be loading the stale <code>.d.ts</code> instead of using the
up-to-date JSDoc types, which sounds like a hot mess.</p>
<p>You might tell me that hey, we don‚Äôt really need a <code>.d.ts</code> to be
generated for the test file, and you would be right. Replacing <code>*.js</code> by
<code>index.js</code> in the above example does fix the problem.</p>
<p>But sometimes, I‚Äôm dealing with a more complex package where the
structure would look something like this:</p>
<pre><code class="hljs">my-cool-package
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ <span class="hljs-addition">some-other-file.js</span>
‚îî‚îÄ‚îÄ test.js</code></pre>
<p>As soon as <code>index.js</code> imports <code>some-other-file.js</code>, we‚Äôre off the happy
path for TypeScript again.</p>
<p>I wrote about this in more details in <a href="typescript-cannot-write-file-overwrite-input.html">cannot write file <code>.d.ts</code> because it would overwrite input file</a>,
and you have many options to go about this, including splitting the code
in a <code>src</code> or <code>dist</code> directory or some combination of both, and while
they all solve this particular problem, they also all leak into other
aspects that you‚Äôll have to work around.</p>
<p>For example in the ‚Äúcomplex‚Äù case above, you might want to allow
your users to <code>import 'my-cool-package/some-other-file'</code>, and not just
<code>import 'my-cool-package'</code>. How wild would that be?</p>
<p>Apparently, wild enough that most of the recommended solutions for the
earlier problem will fail to deliver types information for that use
case, or require you to do crazy things like copying your <code>package.json</code>
to the <code>dist</code> directory and publishing from there.</p>
<h2 id="the-simple-hack-that-just-works" tabindex="-1"><a class="header-anchor" href="#the-simple-hack-that-just-works"><span>The simple hack that just works</span></a></h2>
<p>Because I prefer a simple hack that just works to a fix that will break
other things and require a cascade of other fixes, I settled for the
following command:</p>
<pre><code class="hljs"><span class="hljs-addition">rm -f *.d.ts && </span>tsc *.js --allowJs --declaration --emitDeclarationOnly</code></pre>
<p>It‚Äôs simple, reliable, it works and I understand every bit of why it
works and why it needs to be there (as much as I hate that it needs to
be there in the first place).</p>
<p>I also added <code>--removeComments</code> and replaced <code>--allowJs</code> by <code>--checkJs</code>
to make sure that the code passes type checking when I generate the
final definitions.</p>
<p>In my <code>package.json</code>, the final <code>scripts</code> property looks like this:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;check&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc *.js --checkJs --noEmit&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;standard&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run lint &amp;&amp; npm run types&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rm *.d.ts &amp;&amp; tsc *.js --checkJs --declaration --emitDeclarationOnly --removeComments&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>As always, I use <a href="https://standardjs.com/"><code>standard</code></a> to lint my code,
and in the <a href="https://docs.npmjs.com/cli/v7/using-npm/scripts#life-cycle-scripts"><code>prepare</code></a>
script, the code is linted, typed checked and the definitions are
updated.</p>
<p>There‚Äôs also a convenience <code>check</code> script that doesn‚Äôt emits the
declaration files, to be used for quick checks during development.</p>
<h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2>
<p>As usual with TypeScript it was a pain in the ass to get this to work
and (also as usual) I had to resort to a hack at the end of the day. But
that‚Äôs mostly because I‚Äôm a perfectionist and I wasn‚Äôt happy with having
just the happy path working. üòú</p>
<p>Still, I believe that this method allows to reduce the gap between
TypeScript and JavaScript, while <strong>getting rid of manual work</strong>, making
the JavaScript code <strong>safer</strong>, and making the type definitions <strong>more
accurate and reliable</strong> by tightly coupling them to the code.</p>
<p>Because it yields <strong>most of the benefit</strong> at the <strong>lowest cost and
initial investment</strong>, TypeScript-aware JSDoc comments is likely to
become my go-to for writing JS libraries from now on.</p>
<p>What do you think of this solution? Have you used it yourself, or did
this make you want to type your projects this way? Feel free to <a href="/val.html#contact">reach out</a>
and let me know. And as usual, keep hacking! ‚ú®</p>
<section class="post-footer">
  <h3>Want to leave a comment?</h3>
  <p>
    Join the discussion on <a href="https://twitter.com/valeriangalliat/status/1449783928970256394">Twitter</a> or send me an <a href="mailto:val@codejam.info">email</a>! üíå<br>
    This post helped you? <a href="https://ko-fi.com/funkyval">Buy me a coffee</a>! üçª
  </p>
</section>
  </div>
  <footer>
    <div class="footer-inner">
      <figure>
        <a href="/val.html">
          <img alt="The author (Val) in front of a mountain" src="/img/profile.jpg">
        </a>
      </figure>
      <div class="footer-content">
        <p>
          Made with üß° by <a href="/val.html">Val</a>.
          Generated from a <abbr title="Pull requests welcome!"><a href="https://github.com/valeriangalliat/blog/tree/master/2021/10/jsdoc-typescript-inside-javascript.md">public repository</a></abbr>.
        </p>
        <ul class="social">
          <li>
            <a href="https://twitter.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Twitter</title>
                <use href="/img/icons/407-twitter.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://github.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>GitHub</title>
                <use href="/img/icons/433-github.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.instagram.com/funkyval_/">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Instagram</title>
                <use href="/img/icons/403-instagram.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.youtube.com/@FunkyVal">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>YouTube</title>
                <use href="/img/icons/414-youtube.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://ko-fi.com/funkyval">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Buy me a coffee!</title>
                <use href="/img/icons/219-heart.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="/feed.xml">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>RSS</title>
                <use href="/img/icons/412-rss.svg#icon"></use>
              </svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </footer>
  <script src="/js/emojicon.js"></script>
  <script src="/js/main-20230317.js"></script>
</body>
</html>

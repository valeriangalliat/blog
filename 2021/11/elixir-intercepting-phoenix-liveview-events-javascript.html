<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Elixir: intercepting Phoenix LiveView events in JavaScript</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/github.css">
  <link rel="stylesheet" href="/css/main-20211017.css">
  <link rel="icon" href="/favicon.ico" data-emoji="🏕">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="CodeJam">
  <meta property="og:title" content="Elixir: intercepting Phoenix LiveView events in JavaScript">
  <meta property="og:description" content="Recently, I was dealing with a Phoenix LiveView where I wanted to intercept some events from the LiveSocket to take specific action in JavaScript.">
  <meta property="og:image" content="https://www.codejam.info/img/profile.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@valeriangalliat">
  <meta name="twitter:creator" content="@valeriangalliat">
</head>
<body class="post">
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/val.html">About</a></li>
      <li><a href="https://photography.codejam.info/">Photography</a></li>
    </ul>
    <ul class="social">
      <li>
        <a href="https://www.youtube.com/FunkyVal">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <title>YouTube</title>
            <use href="/img/icons/414-youtube.svg#icon"></use>
          </svg>
        </a>
      </li>
      <li>
        <a href="https://www.instagram.com/funkyval_/">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <title>Instagram</title>
            <use href="/img/icons/403-instagram.svg#icon"></use>
          </svg>
        </a>
      </li>
      <li>
        <a href="https://twitter.com/valeriangalliat">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <title>Twitter</title>
            <use href="/img/icons/407-twitter.svg#icon"></use>
          </svg>
        </a>
      </li>
      <li>
        <a href="https://github.com/valeriangalliat">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <title>GitHub</title>
            <use href="/img/icons/433-github.svg#icon"></use>
          </svg>
        </a>
      </li>
      <li>
        <a href="https://ko-fi.com/funkyval">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <title>Buy me a coffee!</title>
            <use href="/img/icons/219-heart.svg#icon"></use>
          </svg>
        </a>
      </li>
      <li>
        <a href="/feed.xml">
          <svg width="16" height="16" viewBox="0 0 16 16">
            <title>RSS</title>
            <use href="/img/icons/412-rss.svg#icon"></use>
          </svg>
        </a>
      </li>
    </ul>
  </nav>
  <header>
    <div class="header-inner">
      <div class="content">
<h1>Elixir: intercepting Phoenix LiveView events in JavaScript</h1>
<p class="date">November 5, 2021</p>
      </div>
    </div>
  </header>
  <div class="content">
<p>Recently, I was dealing with a Phoenix LiveView where I wanted to
intercept some events from the LiveSocket to take specific action in
JavaScript.</p>
<p>Typically, I wanted to know when a form was done being submitted and
processed by the backend <strong>even if that event didn’t trigger a DOM
change</strong>.</p>
<h2 id="the-use-case" tabindex="-1"><a class="header-anchor" href="#the-use-case"><span>The use case</span></a></h2>
<p>To give the context, I have a <code>&lt;span&gt;</code> that is transformed to a <code>&lt;form&gt;</code>
on click. For reactivity, this is done in JavaScript. When the form is
submitted, it triggers a Phoenix event that might or might not update
the DOM.</p>
<p>I don’t want to reset the state back to the <code>&lt;span&gt;</code> on submission,
because it would temporarily show the old text until the update is
processed by the backend and the DOM is updated, which causes a quick
text flash.</p>
<p>In the happy path where the form submission triggers a DOM update
Phoenix resets the DOM to the <code>&lt;span&gt;</code> and everything is good, but
if we just added a bunch of spaces to the existing text and the backend
decides to trim the value, Phoenix is smart enough to notice that since
the input state didn’t change, it doesn’t need to update the DOM. This
is great, except it leaves us with the open <code>&lt;form&gt;</code> even if the
submission was handled successfully.</p>
<p>To deal with this, I wanted a way to tell from JavaScript when the form
submission was <em>completed</em> so that I can make sure to reset the <code>&lt;span&gt;</code>
only then (to avoid the quick text flash mentioned earlier).</p>
<h2 id="using-phoenix-liveview-hooks" tabindex="-1"><a class="header-anchor" href="#using-phoenix-liveview-hooks"><span>Using Phoenix LiveView hooks?</span></a></h2>
<p>The first thing I thought about was to use LiveView hooks as documented
in <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html">JavaScript interoperability</a>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { Socket } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;phoenix&#x27;</span>
<span class="hljs-keyword">import</span> { LiveSocket } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;phoenix_live_view&#x27;</span>

<span class="hljs-keyword">const</span> csrfToken = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;meta[name=&#x27;csrf-token&#x27;]&quot;</span>).getAttribute(<span class="hljs-string">&#x27;content&#x27;</span>)

<span class="hljs-keyword">const</span> liveSocket = <span class="hljs-keyword">new</span> LiveSocket(<span class="hljs-string">&#x27;/live&#x27;</span>, Socket, {
  <span class="hljs-attr">params</span>: { <span class="hljs-attr">_csrf_token</span>: csrfToken },
  <span class="hljs-attr">hooks</span>: {
    <span class="hljs-attr">ElementUpdated</span>: {
      updated (e) {
        <span class="hljs-built_in">this</span>.el.dispatchEvent(<span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&#x27;phx:element-updated&#x27;</span>))
      }
    }
  }
})

liveSocket.connect()
</code></pre>
<p>By adding <code>phx-hook=&quot;ElementUpdated&quot;</code> on the elements we want to get
notified for updates, we trigger the hook we defined, which here
dispatches a custom <code>phx:element-updated</code> on the node. This allows us to
handle that event at the node level instead of trying to handle every
single case directly from the hook, which is very nice and decoupled if
you ask me.</p>
<p>For example you could now do:</p>
<pre><code class="hljs language-js">someElement.addEventListener(<span class="hljs-string">&#x27;phx:element-updated&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// Deal with the fact this element got updated!</span>
})
</code></pre>
<p>Sadly, this didn’t work for me because the <code>updated</code> hook only fires
when the element is… updated, which is not the case if the form
submission completes but doesn’t result in a state change. Bummer.</p>
<h2 id="leveraging-the-phx-page-loading-stop-window-event" tabindex="-1"><a class="header-anchor" href="#leveraging-the-phx-page-loading-stop-window-event"><span>Leveraging the <code>phx:page-loading-stop</code> <code>window</code> event</span></a></h2>
<p>This is the easiest solution. Unlike the one I talk about after, it
doesn’t give any granularity on the kind of event that was sent or
received, but it’s very easy to implement.</p>
<p>In my case, I use <a href="https://alpinejs.dev/">Alpine</a> so my code looks something like this:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">x-data</span>=<span class="hljs-string">&quot;{ edit: false }&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;edit = true&quot;</span> @<span class="hljs-attr">click.outside</span>=<span class="hljs-string">&quot;edit = false&quot;</span> @<span class="hljs-attr">phx:page-loading-stop.window</span>=<span class="hljs-string">&quot;edit = false&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">x-show</span>=<span class="hljs-string">&quot;!edit&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- ... --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">x-show</span>=<span class="hljs-string">&quot;edit&quot;</span> <span class="hljs-attr">phx-submit</span>=<span class="hljs-string">&quot;edit_whatever&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- ... --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- ... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>We start with a state of <code>edit: false</code>. When that element is clicked, we
switch the <code>&lt;span&gt;</code> to a <code>&lt;form&gt;</code> to let the user edit it. On
submission, if the DOM is refreshed, Phoenix will reset the state
anyways and we’re back to the <code>&lt;span&gt;</code>, but if it’s not (e.g. input not
modified), we can still handle the <code>page-loading-stop</code> event to go back
to <code>&lt;span&gt;</code> mode. Sweet!</p>
<div class="note">
<p><strong>Note:</strong> if you don’t use Alpine, you can just listen to the
<code>phx:page-loading-stop</code> event on the <code>window</code> object:</p>
<pre><code class="hljs language-js">addEventListener(<span class="hljs-string">&#x27;phx:page-loading-stop&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// Your code here!</span>
})
</code></pre>
</div>
<h2 id="monkey-patching-the-livesocket" tabindex="-1"><a class="header-anchor" href="#monkey-patching-the-livesocket"><span>Monkey patching the LiveSocket 🙈</span></a></h2>
<p>Oh yeah, we love monkey patching. If you use Phoenix LiveView your code
should look something like this (I left alone the Alpine part because
it’s not relevant to this example).</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { Socket } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;phoenix&#x27;</span>
<span class="hljs-keyword">import</span> { LiveSocket } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;phoenix_live_view&#x27;</span>

<span class="hljs-keyword">const</span> csrfToken = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;meta[name=&#x27;csrf-token&#x27;]&quot;</span>).getAttribute(<span class="hljs-string">&#x27;content&#x27;</span>)

<span class="hljs-keyword">const</span> liveSocket = <span class="hljs-keyword">new</span> LiveSocket(<span class="hljs-string">&#x27;/live&#x27;</span>, Socket, {
  <span class="hljs-attr">params</span>: { <span class="hljs-attr">_csrf_token</span>: csrfToken }
})

liveSocket.connect()
</code></pre>
<p>From there, we can intercept the <code>push</code> method on the LiveSocket
channel. That will in turn allow us to add an event handler to the
<code>receive</code> event for a given push, so that we can not only get the full
response from Phoenix, but can also tell from what event it originated!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> channel = <span class="hljs-built_in">Object</span>.values(liveSocket.roots)[<span class="hljs-number">0</span>].channel
<span class="hljs-keyword">const</span> pushImpl = channel.push

channel.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedPush</span> (<span class="hljs-params">event, payload, timeout</span>) </span>{
  <span class="hljs-keyword">const</span> push = pushImpl.call(<span class="hljs-built_in">this</span>, event, payload, timeout)

  push.receive(<span class="hljs-string">&#x27;ok&#x27;</span>, <span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event, payload, resp)
  })

  <span class="hljs-keyword">return</span> push
}
</code></pre>
<p>In the case of my <code>&lt;form&gt;</code> example earlier, <code>event</code> is set to the string
<code>event</code>, <code>resp</code> would contain a <code>diff</code> object that really only makes
sense to Phoenix (or be an empty object if nothing was updated), and the
<code>payload</code> would look something like this:</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;form&quot;</span>,
  <span class="hljs-attr">&quot;event&quot;</span>: <span class="hljs-string">&quot;edit_whatever&quot;</span>,
  <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;URL encoded string of the form elements&quot;</span>
}
</code></pre>
<p>This gives pretty useful informations that can allow to hook to LiveView
events in a much more granular manner!</p>
<p>While I didn’t end up needing that method, I found this trick during my
numerous attempts at dealing with that issue and I found it would be
pretty useful to documented as it’s pretty easy to implement and I
didn’t find anything similar online.</p>
<h2 id="further-reading" tabindex="-1"><a class="header-anchor" href="#further-reading"><span>Further reading</span></a></h2>
<p>If you enjoy reading about this topic, I encourage you to read those two
articles I stumbled upon during my research on this subject.</p>
<ul>
<li><a href="http://blog.pthompson.org/alpine-js-and-liveview">Integrating Phoenix LiveView with JavaScript and AlpineJS</a>
by <a href="http://blog.pthompson.org/">Patrick Thompson</a>, for a cool demo of
using hooks and events to make LiveView and Alpine play nice together
(but sadly not nice enough for my edge case).</li>
<li><a href="https://elixirschool.com/blog/live-view-with-channels/">Using channels with LiveView for better UX</a>
by <a href="https://twitter.com/sm_debenedetto">Sophie DeBenedetto</a>, to extend
the LiveSocket with a custom channel that allow passing granular
messages to the client. It’s pretty complex and it kinda scared me at
first to be honest, but if my <a href="monkey-patching-the-livesocket">monkey patch</a>
solution wasn’t flexible enough for you, this one surely will!</li>
</ul>
<section class="post-footer">
  <h3>Want to leave a comment?</h3>
  <p>Join the discussion on <a href="https://twitter.com/valeriangalliat/status/1456786062039261187">Twitter</a> or send me an <a href="mailto:val@codejam.info">email</a>! 💌
</section>
  </div>
  <footer>
    <p>
      Made with 🧡 by <a href="/val.html">Val</a> in Montreal.<br>
      Generated from a <a href="https://github.com/valeriangalliat/blog/tree/master/2021/11/elixir-intercepting-phoenix-liveview-events-javascript.md">public repository</a>. Feel free to <a href="/val.html#contact">contact me</a>, I'd love to hear your thoughts!
    </p>
  </footer>
  <script src="/js/emojicon.js"></script>
  <script src="/js/main-20210719.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Firebase functions in a monorepo? A challenging pile of hacks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>document.documentElement.classList.add(localStorage.theme || ((matchMedia && matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light'))</script>
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/github-20220617.css">
  <link rel="stylesheet" href="/css/main-20230317.css">
  <link rel="icon" href="/favicon.ico" data-emoji="ğŸ•ï¸">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="CodeJam">
  <meta property="og:title" content="Firebase functions in a monorepo? A challenging pile of hacks">
  <meta property="og:description" content="I recently went through the trouble of migrating a Firebase app to a monorepo, in particular the Cloud Functions part. While doing so, I went through a total of 3 different â€œmethodsâ€, all of which were full of surprises that I discovered along the way.">
  <meta property="og:image" content="https://www.codejam.info/img/profile.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@valeriangalliat">
  <meta name="twitter:creator" content="@valeriangalliat">
</head>
<body class="post">
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/val.html">About</a></li>
      <li><a href="https://photography.codejam.info/">Photography</a></li>
      <li class="pull"><button title="Toggle theme" class="change-color-theme">ğŸŒ</button></li>
    </ul>
  </nav>
  <header>
    <div class="header-inner">
      <div class="content">
<h1>Firebase functions in a monorepo? A challenging pile of hacks</h1>
<p class="date">April 7, 2023</p>
      </div>
    </div>
  </header>
  <div class="content">
<p>I recently went through the trouble of migrating a Firebase app to a
monorepo, in particular the Cloud Functions part. While doing so, I went
through a total of 3 different â€œmethodsâ€, all of which were full of
surprises that I discovered along the way.</p>
<p>In this blog post Iâ€™ll go through those 3 options, and highlight their
tradeoffs, in order to help you pick the one thatâ€™s the most appropriate
to your workflow. Itâ€™s a long post, so feel free to jump to the
<a href="#comparison">comparison</a> directly, and then cherry pick what to read
from there. ğŸ˜„</p>
<p>Here, I assume that your monorepo uses something like npm or Yarn
workspaces. It may be applicable to pnpm but I didnâ€™t try it.</p>
<h2 id="the-common-ground" tabindex="-1"><a class="header-anchor" href="#the-common-ground"><span>The common ground</span></a></h2>
<p>Before we get started with the 3 options, they all share a common
ground. And for the sake of this blog post, Iâ€™ll start with an
hypothetical base monorepo structure which Iâ€™ll lay down below.</p>
<h3 id="the-base-monorepo" tabindex="-1"><a class="header-anchor" href="#the-base-monorepo"><span>The base monorepo</span></a></h3>
<p>This is a basic monorepo with two websites and a shared package, e.g.
for helper functions, types or any other common code.</p>
<pre><code class="hljs">monorepo
â”œâ”€â”€ apps
â”‚   â”œâ”€â”€ website1
â”‚   â”‚   â””â”€â”€ package.json
â”‚   â””â”€â”€ website2
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ packages
â”‚   â””â”€â”€ shared
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ package-lock.json
â””â”€â”€ package.json
</code></pre>
<p>The top-level <code>package.json</code> contains:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;workspaces&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">&quot;apps/*&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;packages/*&quot;</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 id="the-firebase-functions-in-its-own-repo" tabindex="-1"><a class="header-anchor" href="#the-firebase-functions-in-its-own-repo"><span>The Firebase functions in its own repo</span></a></h3>
<p>In another repo, you have a Firebase app with functions:</p>
<pre><code class="hljs">firebase
â”œâ”€â”€ functions
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”œâ”€â”€ package-lock.json
â”‚   â””â”€â”€ package.json
â””â”€â”€ firebase.json
</code></pre>
<p>Where your <code>firebase.json</code> contains:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;functions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;functions&quot;</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h3 id="merging-them-together" tabindex="-1"><a class="header-anchor" href="#merging-them-together"><span>Merging them together</span></a></h3>
<p>Since in a Firebase repo, <code>functions</code> is already its own subdirectory
with its own <code>package.json</code>, it feels pretty natural to just â€œmergeâ€
both repos together, maybe  renaming <code>functions</code> into <code>apps/functions</code>
to match our initial structure better, but no more than that:</p>
<pre><code class="hljs language-diff"> monorepo
 â”œâ”€â”€ apps
 â”‚   â”œâ”€â”€ website1
 â”‚   â”‚   â””â”€â”€ package.json
 â”‚   â”œâ”€â”€ website2
 â”‚   â”‚   â””â”€â”€ package.json
<span class="hljs-addition">+â”‚   â””â”€â”€ functions</span>
<span class="hljs-addition">+â”‚       â”œâ”€â”€ src</span>
<span class="hljs-addition">+â”‚       â”‚   â””â”€â”€ index.js</span>
<span class="hljs-addition">+â”‚       â””â”€â”€ package.json</span>
 â”œâ”€â”€ packages
 â”‚   â””â”€â”€ shared
 â”‚       â””â”€â”€ package.json
<span class="hljs-addition">+â”œâ”€â”€ firebase.json</span>
 â”œâ”€â”€ package-lock.json
 â””â”€â”€ package.json
</code></pre>
<p>In <code>firebase.json</code>, we just update the <code>source</code> to be <code>apps/functions</code>,
and we remove the <code>functions/package-lock.json</code> to let npm merge the
functions dependencies in the top-level <code>package-lock.json</code>. This way,
we only need to run <code>npm install</code> at the root of the monorepo, instead
of having to go inside <code>apps/functions</code> and run <code>npm install</code> there
again. After all, thatâ€™s part of the point of a monorepo.</p>
<p>Great, so weâ€™re done? That was easy.</p>
<h2 id="why-this-works-but-not-really" tabindex="-1"><a class="header-anchor" href="#why-this-works-but-not-really"><span>Why this works, but not really</span></a></h2>
<p>Not so fast. This will seemingly work, but it will do so kind of by
chance, as a somewhat lucky accident.</p>
<h3 id="how-firebase-deploy-works" tabindex="-1"><a class="header-anchor" href="#how-firebase-deploy-works"><span>How <code>firebase deploy</code> works</span></a></h3>
<p>See, when <code>firebase deploy</code> deploys the functions, it will make a ZIP
archive of the functions source directory (as defined in <code>firebase.json</code>).</p>
<p>Then, it will deploy the function from that ZIP. The Cloud Functions
deploy process will send that ZIP to Cloud Build, which will:</p>
<ol>
<li>Run some variant of <code>npm install</code> or <code>yarn install</code>.</li>
<li>Run the <code>gcp-build</code> script if defined in <code>package.json</code>.</li>
<li>Prune development dependencies from <code>node_modules</code> if needed.</li>
<li>Use the output of that process as the source for the function
runtime.</li>
</ol>
<p>This is defined in GCP buildpacks, e.g. <a href="https://github.com/GoogleCloudPlatform/buildpacks/blob/99553d0a2051834324d621f20ad5355453f675a1/cmd/nodejs/npm/main.go">for npm</a>
and <a href="https://github.com/GoogleCloudPlatform/buildpacks/blob/99553d0a2051834324d621f20ad5355453f675a1/cmd/nodejs/yarn/main.go">for Yarn</a>.</p>
<p>We can already see a bit of a problem. Because weâ€™re sending only the
<code>apps/functions</code> context to Cloud Build, it doesnâ€™t have access to the
top-level <code>package-lock.json</code>, which means the install output will be
nondeterministic, and each deploy is subject to using different versions
of different packages and potentially break your code without you
knowing.</p>
<p><strong>This can introduce a whole range of sneaky errors that will be a pain to
debug!</strong></p>
<h3 id="using-shared-packages" tabindex="-1"><a class="header-anchor" href="#using-shared-packages"><span>Using shared packages</span></a></h3>
<p>Moreover, we now understand that this will not allow using <em>shared
packages</em> inside the monorepo!</p>
<p>If we wanted to use <code>packages/shared</code> inside <code>apps/functions</code>, by adding
<code>&quot;shared&quot;: &quot;*&quot;</code> in our <code>dependencies</code>, letting npm or Yarn resolve it to
the local workspace version, it wouldnâ€™t actually work.</p>
<p>Or actually, it will work in development, because we have the whole
monorepo there. And in our particular example, even the Firebase
deployment will surprisingly succeed, <strong>but only as an accident because
<a href="https://www.npmjs.com/package/shared"><code>shared</code></a> is a valid npm
package</strong>! It will break at runtime when you try to use a package that
doesnâ€™t contain the code you expect at all.</p>
<p>Other names for common monorepo shared packages that are also valid npm
packages would be <a href="https://www.npmjs.com/package/eslint-config"><code>eslint-config</code></a>
and <a href="https://www.npmjs.com/package/tsconfig"><code>tsconfig</code></a>, so they would
also result in this kind of collision.</p>
<div class="note">
<p><strong>Note:</strong> if you use Yarn, you can prevent those collisions by prefixing
your version specifier for your shared dependencies with <code>workspace:</code>,
e.g. <code>&quot;shared&quot;: &quot;workspace:*&quot;</code> to use any version. This will ensure the
dependency is <em>always</em> installed from the local workspace and not from
the registry.</p>
<p>npm doesnâ€™t support that, but you can still add a layer of safety by
making sure all your shared package names donâ€™t conflict with anything
on npm, for example by prefixing them with <code>@myorg</code> such as
<code>@myorg/shared</code>, <code>@myorg/eslint-config</code>, <code>@myorg/tsconfig</code> and so on.</p>
<p>Or as an abundance of caution if you use Yarn, maybe do both. ğŸ˜¬</p>
</div>
<h2 id="the-good-enough-for-me-approach" tabindex="-1"><a class="header-anchor" href="#the-good-enough-for-me-approach"><span>The â€œgood enough for meâ€ approach</span></a></h2>
<p>Weâ€™re now in a situation where 1. the top-level <code>package-lock.json</code> is
not respected when deploying Cloud Functions, and 2. we cannot use any
workspace shared package in our functions.</p>
<p>You may actually be fine with that. Maybe you donâ€™t care that your
production functions have an unpredictable dependency tree every time
you deploy, and maybe you donâ€™t want to use shared packages in your
functions anyway!</p>
<div class="note">
<p><strong>Note:</strong> you can even use shared packages in your <code>devDependencies</code>
with that setup, as long as you donâ€™t have a <code>gcp-build</code> script that
depends on them!</p>
<p>At least if you use npm. Because thereâ€™s currently a bug with the Yarn
Cloud Build buildpack that makes it install <code>devDependencies</code> before
pruning them right after, even when no build script is present. ğŸ˜…</p>
<p>This would fail your build if the shared package from your
<code>devDependencies</code> donâ€™t exist on npm. Itâ€™s one of those cases where
having a shared package name that collisions with a npm package would
help, although I wouldnâ€™t really recommend this as a fix.</p>
</div>
<p>If that works for you, congratulations, your job here is done.
Otherwise, letâ€™s dig in the two other options. ğŸ‘‡</p>
<h2 id="the-full-context-approach" tabindex="-1"><a class="header-anchor" href="#the-full-context-approach"><span>The full context approach</span></a></h2>
<p>Thereâ€™s a <a href="https://github.com/firebase/firebase-tools/issues/653">long thread</a>
in the <code>firebase-tools</code> repo about monorepo support. The majority of the
solutions described there are some variation of a deploy script that
packs your shared dependencies into <code>.tgz</code> files, and patch the
<code>functions/package.json</code> file to reference them with <code>file:</code> for the
time of the deployment. Weâ€™ll explore this in details in the last solution: <a href="#the-hybrid-approach">the hybrid approach</a>.</p>
<p>However, thereâ€™s <a href="https://github.com/firebase/firebase-tools/issues/653#issuecomment-1371306331">a particular comment</a>
in that thread that describes something very different, and caught my
attention despite not being given very much interest there.</p>
<figure class="center">
  <img alt="A comment suggesting to put the monorepo root as the functions source" srcset="../../img/2023/04/firebase-monorepo-comment.png 2x">
</figure>
<p>This comment suggests that we put the monorepo root as the functions
source in <code>firebase.json</code> (ignoring unnecessary files as needed), to
ensure we send the whole relevant monorepo context to Cloud Build!</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;functions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;source&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;ignore&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
      <span class="hljs-string">&quot;firebase.json&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">&quot;**/.*&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">&quot;**/node_modules/**&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-string">&quot;**/packages/@(web|mobile)/**&quot;</span>
    <span class="hljs-punctuation">]</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>Then, adding the functions entrypoint in the top-level <code>package.json</code>,
because Cloud Functions still donâ€™t know about monorepos, and expects the
functions <code>package.json</code> to be at the root.</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./packages/functions/dist/index.js&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<div class="note">
<p><strong>Note:</strong> if you use <code>.env</code> files in your functions, e.g. <code>.env</code>,
<code>.env.production</code>, <code>.env.staging</code>, and any other project aliases you may
have, which is becoming more and more common <a href="https://firebase.google.com/docs/functions/config-env#environment_configuration">now Firebase deprecated
<code>functions.config()</code></a>,
you also need to put them at the root of your monorepo with this
solution, otherwise they will be ignored during deploy!</p>
</div>
<p>To me, this sounds <em>much more elegant</em> than the hacks with deploy
scripts and <code>file:</code> references! But after using this approach in
production for a few weeks, I decided to rollback, because there was too
many downsides for my use case.</p>
<h3 id="the-ignore-list-is-quirky" tabindex="-1"><a class="header-anchor" href="#the-ignore-list-is-quirky"><span>The ignore list is quirky</span></a></h3>
<p>The ignore list is not exactly intuitive to work with. And if you forget
to ignore anything somewhat large, <a href="firebase-functions-entity-too-large.html">your functions will fail to deploy</a>.
It struggled so much to figure out the precise rules of this ignore list
that I had to go in the <code>firebase-tools</code> source code in order to
understand it, and I wrote <a href="firebase-functions-ignore.html">another blog post</a>
to explain how it really works, and how to test your ignore patterns!</p>
<p>The main caveat is that you <a href="https://github.com/firebase/firebase-tools/issues/2677">canâ€™t use negative ignore rules</a>
like you could in <code>.gitignore</code> and most ignore systems, e.g.:</p>
<pre><code class="hljs language-gitignore">/apps/website1/*
!/apps/website1/package.json
/apps/website2/*
!/apps/website2/package.json
</code></pre>
<p>In a <code>.gitignore</code>, this would ignore everything in <code>apps/website1</code> and
<code>apps/website2</code> except for their <code>package.json</code>. If you use â€œa modern
version of Yarnâ€ (not 1.x), this is something you would need to do, because
<code>yarn install --immutable</code> will fail if the workspaces identified in
your <code>yarn.lock</code> donâ€™t actually point to directories with a
<code>package.json</code> in them!</p>
<p>If you use npm or Yarn 1.x though, <code>npm ci</code> and <code>yarn install --frozen-lockfile</code> wonâ€™t care, so youâ€™re good to go.</p>
<div class="note">
<p><strong>Note:</strong> just keep in mind that Yarn 1.x doesnâ€™t let you install
dependencies for a single workspace, you systematically have to install
all dependencies for the whole monorepo, which can be a pretty bad hit
for any pipeline that works only on a small subset of the monorepo.</p>
<p>While you can <a href="https://classic.yarnpkg.com/en/docs/cli/install#toc-yarn-install-focus"><code>yarn install --focus</code></a>
with 1.x, which kind of sounds like this, it doesnâ€™t work with
dependencies that are local to the monorepo, they <em>need</em> to be fetched
from a registry.</p>
</div>
<p>But on new Yarn versions, this is a pretty big deal because you canâ€™t
ignore a whole workspace from your functions deploy, and because thereâ€™s
no negative patterns to ignore everything but the <code>package.json</code> in a
given workspace, youâ€™re stuck with having to <em>explicitly</em> ignore
everything but the <code>package.json</code> in each of the workspaces you want to
exclude. And itâ€™s a list youâ€™ll now have to maintain forever every time
you add new things to your monorepo.</p>
<p>This is even more of a problem because if you have any kind of secret in
your repo, and you fail to add them to your <code>functions.ignore</code> list,
theyâ€™ll be packaged in your functions source and you wonâ€™t notice. Your
functions source is private to your Google Cloud account by default, but
this is silently waiting to make a future security issue much worse.</p>
<h3 id="all-the-other-workspace-dependencies-are-installed" tabindex="-1"><a class="header-anchor" href="#all-the-other-workspace-dependencies-are-installed"><span>All the other workspace dependencies are installed</span></a></h3>
<p>This is the one that made me give up this solution. I could deal with
the ignore list issues, but this was another level.</p>
<p>As we saw earlier, Cloud Functions use Cloud Build to install your
dependencies. The whole thing is not designed for monorepos, which is
why we had to put our <code>main</code> entrypoint in the root <code>package.json</code>. A
more concerning effect of that though, is that Cloud Build will run <code>npm install</code>
at the top level of the monorepo.</p>
<p>This means installing all the dependencies of all your apps and
packages. This is big problem if you have a lot of unrelated
dependencies across your different workspaces.</p>
<p>Firebase doesnâ€™t let you configure the install command either, to run
e.g. <code>npm install --workspace functions</code> or <code>yarn workspace function workspaces focus</code>
(I know, awkward command), which would install only the functions
dependencies. <em>This can speed up your install times drastically</em> in
remote build environments, but here itâ€™s not an option.</p>
<p>For us, the difference was 10 minutes to deploy Firebase functions vs. 2
minutes, if we could install the dependencies of the functions only.</p>
<p>This was to much, which is why I ended up with the last approach.</p>
<div class="note">
<p><strong>Note:</strong> the build time issue was heavily magnified in my case by the
fact Cloud Build <a href="https://github.com/GoogleCloudPlatform/buildpacks/issues/203">doesnâ€™t do any caching for Yarn 2.x and greater</a>
if itâ€™s not used in <a href="https://yarnpkg.com/features/pnp">PnP mode</a>.
Proper caching may help a bit with npm and Yarn 1.x, even though itâ€™s
still not ideal.</p>
<p>There may be a way though, for example by replacing the top-level
<code>package.json</code> and <code>package-lock.json</code> by dummy ones during <code>firebase deploy</code> so that from Cloud Buildâ€™s perspective it looks like you have no
dependencies, and then hijacking the <code>gcp-build</code> script to <em>actually</em>
install your dependencies yourself using the appropriate command that
doesnâ€™t install the whole world at the same time. ğŸ¥¹</p>
<p>I havenâ€™t tested this but it may work. However, if youâ€™re gonna get that
hacky, you might as well embrace the third solution.</p>
</div>
<h2 id="the-hybrid-approach" tabindex="-1"><a class="header-anchor" href="#the-hybrid-approach"><span>The hybrid approach</span></a></h2>
<p>This is an improved version of <a href="#the-good-enough-for-me-approach">the first â€œgood enough for meâ€ solution</a>,
where in our development environment, we work with a full-fledged
monorepo, with shared packages and everything, but when we deploy the
Firebase functions, we narrow it down to its own independent-repo-like
entity, but in a way that will actually work with our
<code>package-lock.json</code> and shared packages!</p>
<p>This will take a bit of code though, in the form of a <code>predeploy</code> and
<code>postdeploy</code> script for our functions. The <code>predeploy</code> script needs to:</p>
<ol>
<li>Do anything you were already doing in a <code>predeploy</code> script like
linting and building your app.</li>
<li>Copy all the shared packages you depend on in your functions
directory, either through <code>.tgz</code> files from using <code>npm pack</code> or <code>yarn pack</code>, or the directories themselves (see below for the difference).</li>
<li>Patch your functions <code>package.json</code> to reference the internal
dependencies using <code>file:</code> references to the <code>.tgz</code> files or
directories you just created.</li>
<li><strong>Do so recursively for your whole graph of internal dependencies.</strong>
Hopefully itâ€™s small enough to be manageable, but I can see this
turning into a living hell in complex monorepos.</li>
<li>Copy the top-level lock file in the functions directory. If you use
Yarn 2.x and greater, youâ€™ll need to do a bit more than that, see
below.</li>
</ol>
<p>As for the <code>postdeploy</code> script, it needs to undo everything that
<code>predeploy</code> did.</p>
<p>Of course, your repo will be in an inconsistent state for the duration
of <code>firebase deploy</code>, so maybe run that from another copy of your
monorepo that you donâ€™t work from, or make sure to not mess with your
dependencies during the deploy, or things will fall apart!</p>
<p>Youâ€™ll find a number of examples of those <code>predeploy</code> and <code>postdeploy</code>
scripts in the issue thread I linked earlier. Hereâ€™s
<a href="https://github.com/firebase/firebase-tools/issues/653#issuecomment-1464911379">one of the most recent ones</a>
that you can take inspiration from.</p>
<p>For the part where you replace the versions of your internal packages in
your <code>package.json</code>, you can use <a href="https://docs.npmjs.com/cli/v7/commands/npm-pkg"><code>npm pkg set</code></a></p>
<pre><code class="hljs language-sh">npm pkg <span class="hljs-built_in">set</span> <span class="hljs-string">&#x27;dependencies.@myorg/shared=file:shared.tgz&#x27;</span> <span class="hljs-string">&#x27;dependencies.@myorg/tsconfig=file:tsconfig.tgz&#x27;</span>
</code></pre>
<p>Just make a backup of your original <code>package.json</code> so you can restore it
in the <code>postdeploy</code> script. Feel free to use it with Yarn as well since
this really just edits your <code>package.json</code> from the command line.</p>
<p>Now, about the downsides.</p>
<h3 id="you-have-to-recursively-package-your-internal-dependencies" tabindex="-1"><a class="header-anchor" href="#you-have-to-recursively-package-your-internal-dependencies"><span>You have to recursively package your internal dependencies</span></a></h3>
<p>And to do so, you have to patch your <code>package.json</code> files all the way
down the internal dependency graph for your functions. Nasty.</p>
<p>As for using <code>.tgz</code> files from <code>npm pack</code> or <code>yarn pack</code> vs. copying the
directories directly, it comes down to personal preference with npm, but
if you use Yarn and you have nested internal dependencies, youâ€™re much
better off going with the directory approach.</p>
<p>Thatâ€™s because npm can resolve <code>file:</code> references to <code>.tgz</code> files
relative to <em>where <code>npm install</code> is ran from</em>, but Yarn only looks for
the <code>.tgz</code> files relative to the <code>package.json</code> referencing it.</p>
<p>You can see how this becomes a problem with more than one level of
dependency, because you would have to embed the archive of the same
packages in all the packages that reference it, and do so recursively,
which can get exponentially heavy and inefficient! Not to mention that
youâ€™d end up with a lot of duplicated dependencies, which can cause a
whole lot of other problems on its own.</p>
<p>It will work with the directory approach though:</p>
<ol>
<li>You make your functions depend on <code>&quot;@myorg/shared&quot;: &quot;file:shared&quot;</code>.</li>
<li>You make <code>shared/package.json</code> depends on <code>&quot;@myorg/tsconfig&quot;: &quot;file:../tsconfig&quot;</code>.</li>
<li>You copy both <code>shared</code> and <code>tsconfig</code> under your functions directory
and youâ€™re god to go.</li>
</ol>
<h3 id="you-need-to-mirror-some-top-level-logic" tabindex="-1"><a class="header-anchor" href="#you-need-to-mirror-some-top-level-logic"><span>You need to mirror some top-level logic</span></a></h3>
<p>In the previous solution, we saw how we had to copy some functions logic
at the top level (<code>main</code> inside <code>package.json</code> as well as <code>.env</code> files).
Here, we have the opposite problem.</p>
<p>Because weâ€™re shipping only the functions directory to Cloud Functions,
itâ€™s missing your <code>package-lock.json</code> or <code>yarn.lock</code> from the top
level (and maybe a number of other files you may need without knowing it).</p>
<p>For example, if you use â€œa modern version of Yarnâ€ aka not Yarn 1.x, it
also needs its <code>.yarnrc.yml</code> as well as <code>.yarn/releases</code> and
<code>.yarn/plugins</code> directories in order to function!</p>
<p>If you forget to copy any of those inside your functions directory,
Cloud Build will either use the wrong package manager or the wrong
version of your package manager, which may result in the best case in a
broken deploy, or worst, resolving and linking dependencies differently
than in your local environment, which can lead to a number of sneaky
issues.</p>
<p>This is not something thatâ€™s accounted for in any of the solutions from
<a href="https://github.com/firebase/firebase-tools/issues/653">the thread</a>
I linked earlier. <strong>They all ship a lonely <code>functions/package.json</code> that
will end up installing unpredictable dependency versions in their
production environment.</strong></p>
<p>Luckily, this is easy to fix! Just copy your top-level
<code>package-lock.json</code> or <code>yarn.lock</code> in the functions directory as part of
your <code>predeploy</code> script.</p>
<p>npm and Yarn 1.x are resilient enough to do the right thing from a
<em>superset</em> of the lock file. More recent versions of Yarn though, are
pretty strict and will refuse to install if it finds anything
<em>superfluous</em> in <code>yarn.lock</code> (from its partial perspective).</p>
<p>Thereâ€™s a whole bunch of ways to addresses this, tracked in
<a href="https://github.com/yarnpkg/yarn/issues/5428">those</a> <a href="https://github.com/yarnpkg/berry/issues/1223">issues</a>,
with the emerging of various experimental Yarn plugins to fix it like
<a href="https://github.com/andreialecu/yarn-plugin-workspace-lockfile">yarn-plugin-workspace-lockfile</a>
(<a href="https://github.com/bertho-zero/yarn-plugin-workspace-lockfile">and</a>
<a href="https://github.com/milesforks/yarn-plugin-workspace-lockfile">its</a>
<a href="https://github.com/jakebailey/yarn-plugin-workspace-lockfile">forks</a>)
or <a href="https://github.com/JanVoracek/yarn-plugin-entrypoint-lockfiles">yarn-plugin-entrypoint-lockfiles</a>
that maintains individual lock files for each workspaces (or
â€œentrypointâ€) at the cost of slightly slower installs when you add or
remove dependencies.</p>
<p>I initially used some version of this, but while writing this blog post,
I stumbled upon <a href="https://stackoverflow.com/a/73118909/4324668">this StackOverflow comment</a>
that mentions <code>yarn install --mode update-lockfile</code>. This is <em>exactly
what we want</em>! So as of Yarn 3.x, we can just do the following:</p>
<pre><code class="hljs language-sh"><span class="hljs-built_in">cp</span> yarn.lock apps/functions
<span class="hljs-built_in">cd</span> apps/functions
yarn install --mode update-lockfile
</code></pre>
<p>This will updates <code>apps/functions/yarn.lock</code> to contain <em>only</em> the
entries <em>necessary</em> for your functions, while keeping the versions that
were pinned in the original lock file. This will happily work when Cloud
Build runs <code>yarn install --immutable</code> later on. ğŸ˜</p>
<p>Again, this is something you need to do in your <code>predeploy</code> script, and
undo in your <code>postdeploy</code>.</p>
<h2 id="comparison" tabindex="-1"><a class="header-anchor" href="#comparison"><span>Comparison</span></a></h2>
<p>Letâ€™s compare the pros and cons of those 3 options.</p>
<p><strong><a href="#the-good-enough-for-me-approach">Good enough</a></strong></p>
<ul>
<li>ğŸŸ¢ Easy AF.</li>
<li>ğŸŸ¡  Doesnâ€™t use your lock file, youâ€™re installing nondeterministic
versions of your dependencies in production (easily fixable by taking
that specific part of the hybrid approach though).</li>
<li>ğŸ”´ Canâ€™t use workspace shared packages.</li>
</ul>
<p><strong><a href="#the-full-context-approach">Full context</a></strong></p>
<ul>
<li>ğŸŸ¢ Supports your lock file and any other monorepo-wide config
(Yarn version, etc.) by design and out of the box.</li>
<li>ğŸŸ¢ Supports shared workspaces packages by design and out of the box.</li>
<li>ğŸŸ¡ Need to proxy the functions <code>main</code> entrypoint in the top-level <code>package.json</code>,
as well as other things like functions <code>.env</code> files.</li>
<li>ğŸŸ  Need to maintain the <code>functions.ignore</code> list which is clunky,
and gets significantly worst when using modern Yarn versions.</li>
<li>ğŸ”´ It installs your whole monorepo dependencies instead of just your
functions dependencies.</li>
</ul>
<p><strong><a href="#the-hybrid-approach">Hybrid</a></strong></p>
<ul>
<li>ğŸŸ¢ None of the downsides of the previous approach.</li>
<li>ğŸŸ¡ You have to copy your lock file and maybe other global requirements
like your <code>.yarnrc.yml</code>, <code>.yarn</code> folder and alike inside your
functions directory.</li>
<li>ğŸ”´ Needs a <code>predeploy</code> and <code>postdeploy</code> script to package workspace
dependencies inside the functions directories, and recursively patch
their <code>package.json</code> to reference them with <code>file:</code>.</li>
</ul>
<h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2>
<p>Today, we went through 3 methods to make Firebase functions <em>somewhat</em>
work with a monorepo: <a href="#the-good-enough-for-me-approach">the â€œgood enough for meâ€ approach</a>,
<a href="#the-full-context-approach">the full context approach</a>
and <a href="#the-hybrid-approach">the hybrid approach</a>. Finally, we
<a href="#comparison">compared their pros and cons</a>.</p>
<p>By now, you should have everything you need in order to make an educated
decision about which method to pick.</p>
<p>And if you find any other cool trick to make working with Firebase
functions in a monorepo easier, donâ€™t hesitate to <a href="/val.html#contact">let me know</a>!</p>
<section class="post-footer">
  <h3>Want to leave a comment?</h3>
  <p>
    Start a conversation on <a href="https://twitter.com/valeriangalliat">Twitter</a> or send me an <a href="mailto:val@codejam.info">email</a>! ğŸ’Œ<br>
    This post helped you? <a href="https://ko-fi.com/funkyval">Buy me a coffee</a>! ğŸ»
  </p>
</section>
  </div>
  <footer>
    <div class="footer-inner">
      <figure>
        <a href="/val.html">
          <img alt="The author (Val) in front of a mountain" src="/img/profile.jpg">
        </a>
      </figure>
      <div class="footer-content">
        <p>
          Made with ğŸ§¡ by <a href="/val.html">Val</a>.
          Generated from a <abbr title="Pull requests welcome!"><a href="https://github.com/valeriangalliat/blog/tree/master/2023/04/firebase-functions-monorepo.md">public repository</a></abbr>.
        </p>
        <ul class="social">
          <li>
            <a href="https://twitter.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Twitter</title>
                <use href="/img/icons/407-twitter.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://github.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>GitHub</title>
                <use href="/img/icons/433-github.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.instagram.com/funkyval_/">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Instagram</title>
                <use href="/img/icons/403-instagram.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.youtube.com/FunkyVal">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>YouTube</title>
                <use href="/img/icons/414-youtube.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://ko-fi.com/funkyval">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Buy me a coffee!</title>
                <use href="/img/icons/219-heart.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="/feed.xml">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>RSS</title>
                <use href="/img/icons/412-rss.svg#icon"></use>
              </svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </footer>
  <script src="/js/emojicon.js"></script>
  <script src="/js/main-20230317.js"></script>
</body>
</html>

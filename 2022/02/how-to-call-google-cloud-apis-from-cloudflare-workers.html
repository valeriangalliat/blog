<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>How to Call Google Cloud APIs from Cloudflare Workers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>document.documentElement.classList.add(localStorage.theme || ((matchMedia && matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light'))</script>
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/github-20220617.css">
  <link rel="stylesheet" href="/css/main-20260125.css">
  <link rel="icon" href="/favicon.ico" data-emoji="üèïÔ∏è">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="CodeJam">
  <link rel="canonical" href="https://hookdeck.com/blog/post/how-to-call-google-cloud-apis-from-cloudflare-workers">
  <meta property="og:title" content="How to Call Google Cloud APIs from Cloudflare Workers">
  <meta property="og:description" content="Note: this is a mirror of the blog post originally published on Hookdeck blog!">
  <meta property="og:image" content="https://www.codejam.info/img/profile.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@valeriangalliat">
  <meta name="twitter:creator" content="@valeriangalliat">
</head>
<body class="post">
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/val.html">About</a></li>
      <li><a href="/now.html">Now</a></li>
      <li class="pull"><button title="Toggle theme" class="change-color-theme">üåù</button></li>
    </ul>
  </nav>
  <header>
    <div class="header-inner">
      <div class="content">
<h1>How to Call Google Cloud APIs from Cloudflare Workers</h1>
<p class="date">February 16, 2022</p>
      </div>
    </div>
  </header>
  <div class="content">
<div class="note">
<p><strong>Note:</strong> this is a mirror of the blog post originally published on
<a href="https://hookdeck.com/blog/post/how-to-call-google-cloud-apis-from-cloudflare-workers">Hookdeck blog</a>!</p>
</div>
<p>If you want to handle HTTP requests without managing your own
infrastructure, a common solution these days is <em>‚Äúserverless‚Äù functions</em>.</p>
<p>They‚Äôre known as Lambda on AWS, Functions on Google Cloud, Azure, Vercel
and Netlify, Workers on Cloudflare, and EdgeWorkers on Akamai.</p>
<p>But if you also want to do some processing <strong>after</strong> returning a HTTP
response, Cloudflare Workers is the only one that lets you do it.</p>
<p>And because this is a need of ours, we use Cloudflare Workers to handle
webhooks ingestion. This allows us to return a very fast response after
performing some sanity checks, then deal with queuing and possible error
handling and recovery in the background.</p>
<p>But Cloudflare Workers have quite some limitations compared to the most
popular (already pretty limited) serverless functions platforms.</p>
<h2 id="the-problem-with-cloudflare-workers" tabindex="-1"><a class="header-anchor" href="#the-problem-with-cloudflare-workers"><span>The problem with Cloudflare Workers</span></a></h2>
<p>Most of the JavaScript backend ecosystem is built around Node.js, but
Cloudflare Workers is not. Meaning all the usual modules we would
normally <code>import</code> are not there, and we can‚Äôt easily <code>npm install</code>
Node.js dependencies. Cloudflare Workers essentially brought Webpack to
the backend, as well as all the limitations we usually have with
browsers.</p>
<p>And because we depend on Google Cloud Pub/Sub, and the Google Cloud SDK
only has a <strong>Node.js</strong> client for Pub/Sub (not plain JavaScript), we
can‚Äôt use that directly from Cloudflare Workers.</p>
<div class="note">
<p><strong>Note:</strong> Google do offer a pure JavaScript SDK (intended for browser
usage) known as <a href="https://github.com/google/google-api-javascript-client">GAPI</a>
which would syntaxically be compatible with Cloudflare Workers, but it
only supports  OAuth or API key authentication, and not service account
which is necessary in our backend case. See <a href="https://cloud.google.com/docs/authentication#strategies">Google Cloud authentication strategies</a>.</p>
</div>
<p>One solution we had for a while was to call a Google Cloud Function over
HTTP from the Cloudflare Worker, and that Cloud Function could itself
use the Google Cloud Node.js SDK to call Pub/Sub. This worked, but added
an extra overhead to process webhooks, an additional component that can
break, as well as an extra piece of infrastructure to maintain (yeah, I
lied in the beginning of this article, even serverless functions require
you to deal with at least a bit of infrastructure).</p>
<p>So we decided as part of a maintenance effort to remove this Cloud
Function and call directly the Pub/Sub API from Cloudflare, despite the
lack of a pure JavaScript SDK.</p>
<h2 id="homemade-client-overview" tabindex="-1"><a class="header-anchor" href="#homemade-client-overview"><span>Homemade client overview</span></a></h2>
<p>This leaves us to build our own Google Cloud client implementing the
service account authentication. Fortunately, this is a topic that‚Äôs
<a href="https://community.cloudflare.com/t/connecting-to-google-storage/32350">covered</a>
in a few <a href="https://stackoverflow.com/questions/67644213/accessing-google-cloudtasks-api-without-using-googles-sdks">forums</a>
and <a href="https://blog.cloudflare.com/api-at-the-edge-workers-and-firestore/">articles</a>
<a href="https://www.jhanley.com/google-cloud-creating-oauth-access-tokens-for-rest-api-calls/">already</a>.</p>
<p>Here‚Äôs the gist:</p>
<ul>
<li>On Google Cloud, create a service account as well as an IAM user
associated with it.</li>
<li>Give the necessary permissions to that IAM user.</li>
<li>Download the service account JSON key which contains a PEM RSA private
key, a key ID, and a client email.</li>
<li>Thanks to those 3 elements, create and sign a <a href="https://jwt.io/">JWT</a>
that we can be used as a bearer token for Google Cloud APIs, and that
will be accepted as long as the requested permissions in the JWT match
those of the associated IAM user.</li>
</ul>
<p>This involves some <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">SubtleCrypto</a>
magic, which we‚Äôll cover in this article.</p>
<h2 id="passing-the-service-account-json" tabindex="-1"><a class="header-anchor" href="#passing-the-service-account-json"><span>Passing the service account JSON</span></a></h2>
<p>Typically this is done with the Google Cloud SDK by setting a
<code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable to the path of the
service account JSON key file.</p>
<p>Because we‚Äôre managing Cloudflare secrets inside environment variables
and not on the filesystem, we put the JSON string directly in a
<code>GOOGLE_APPLICATION_CREDENTIALS_JSON</code> environment variable. The name is
arbitrary, it‚Äôs only a nudge to the original SDK (that we can‚Äôt use).</p>
<p>On the worker side, we can fetch it from the environment either via a
global variable if you‚Äôre writing a service-worker-style‚Ä¶ worker, or
from the <code>env</code> parameter of the <code>fetch</code> function if you‚Äôre in a
module-style worker:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Service worker</span>
<span class="hljs-keyword">const</span> serviceAccount = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable constant_">GOOGLE_APPLICATION_CREDENTIALS_JSON</span>)

<span class="hljs-comment">// Module</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">fetch</span> (request, env, context) {
    <span class="hljs-keyword">const</span> serviceAccount = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(env.<span class="hljs-property">GOOGLE_APPLICATION_CREDENTIALS_JSON</span>)
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<h2 id="importing-the-rsa-key" tabindex="-1"><a class="header-anchor" href="#importing-the-rsa-key"><span>Importing the RSA key</span></a></h2>
<p>Brace yourselves because I‚Äôm gonna go in a little bit of details about
this. And while you can just scroll to the end of this section and copy
the code, I think it‚Äôs valuable to spend the time to understand
carefully how this all works!</p>
<p>The service account JSON has a <code>private_key</code> string, containing a
PEM-encoded RSA private key that we can use to sign JWTs. It looks
something like this:</p>
<pre><code class="hljs language-js">-----<span class="hljs-variable constant_">BEGIN</span> <span class="hljs-variable constant_">PRIVATE</span> <span class="hljs-variable constant_">KEY</span>-----
<span class="hljs-title class_">MIIBVAIBADANBgkqhkiG</span>9w0BAQEFAASCAT4wggE6AgEAAkEApL8kivZkDZn0NPYR
pVfe8uM+<span class="hljs-title class_">IO8Fk</span>+d3Qd4EaPcD1MHmXY8Jef1T+v33mMNUHTDiEfGi3n/9kmSN4u0p
fr/9rwIDAQABAkEAgQAe6CUYoUHc5B+<span class="hljs-title class_">OH68Xp47</span>i1jzzXCYRzuS/<span class="hljs-title class_">BUXunQfZgncH</span>
<span class="hljs-title class_">EO4LZz</span>/7m6ggAx8dWPaxlsXD4QJZbatlVo4wAQIhANhPWVrWcry8oct3MDMPNLCW
+sP14q3P8fQJDT76rIgBAiEAwvm6k2qPn2S8RLyaD1gHwSgX7/oxS44n8Hztjgwn
<span class="hljs-title class_">Ba8CICp4</span>yg6v9K9iSlJtAKXF4o6Z1nsLmIqQPe2wqU0oYyABAiBk+dqTwCtTnGMY
oiiTa77QXUhQY12mSKAMn1aUK10GRwIgU/+scWe64dWIkodZRorlYjLtJYsjNikR
5MjzJijoE1s=
-----<span class="hljs-variable constant_">END</span> <span class="hljs-variable constant_">PRIVATE</span> <span class="hljs-variable constant_">KEY</span>-----
</code></pre>
<p>Because our Cloudflare Worker is a browser-like environment, we can‚Äôt
use the <a href="https://nodejs.org/api/crypto.html">Node.js <code>crypto</code> module</a> to
deal with cryptography, and we need to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">SubtleCrypto</a>
API instead. But SubtleCrypto <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#parameters">doesn‚Äôt support PEM encoding out of the box</a>.
The good news is that it supports <a href="https://en.wikipedia.org/wiki/PKCS_8">PKCS #8</a> and
<a href="https://datatracker.ietf.org/doc/html/rfc7517">JWK</a>.</p>
<p>PKCS #8 is the standard encoding for private keys. Our PEM private key
above is essentially a PKCS #8 key that‚Äôs Base64-encoded, with the
addition of a header and footer string.</p>
<p>On the other hand, JWK stands for <strong>JSON Web Key</strong>, and it‚Äôs a way to
encode cryptographic keys in a JSON object, as opposed to a binary or
Base64-encoded format.</p>
<p>The same key as above, but formatted as JWK:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">&quot;kty&quot;</span>: <span class="hljs-string">&quot;RSA&quot;</span>,
  <span class="hljs-string">&quot;n&quot;</span>: <span class="hljs-string">&quot;pL8kivZkDZn0NPYRpVfe8uM-IO8Fk-d3Qd4EaPcD1MHmXY8Jef1T-v33mMNUHTDiEfGi3n_9kmSN4u0pfr_9rw&quot;</span>,
  <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-string">&quot;AQAB&quot;</span>,
  <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;gQAe6CUYoUHc5B-OH68Xp47i1jzzXCYRzuS_BUXunQfZgncHEO4LZz_7m6ggAx8dWPaxlsXD4QJZbatlVo4wAQ&quot;</span>,
  <span class="hljs-string">&quot;p&quot;</span>: <span class="hljs-string">&quot;2E9ZWtZyvLyhy3cwMw80sJb6w_Xirc_x9AkNPvqsiAE&quot;</span>,
  <span class="hljs-string">&quot;q&quot;</span>: <span class="hljs-string">&quot;wvm6k2qPn2S8RLyaD1gHwSgX7_oxS44n8HztjgwnBa8&quot;</span>,
  <span class="hljs-string">&quot;dp&quot;</span>: <span class="hljs-string">&quot;KnjKDq_0r2JKUm0ApcXijpnWewuYipA97bCpTShjIAE&quot;</span>,
  <span class="hljs-string">&quot;dq&quot;</span>: <span class="hljs-string">&quot;ZPnak8ArU5xjGKIok2u-0F1IUGNdpkigDJ9WlCtdBkc&quot;</span>,
  <span class="hljs-string">&quot;qi&quot;</span>: <span class="hljs-string">&quot;U_-scWe64dWIkodZRorlYjLtJYsjNikR5MjzJijoE1s&quot;</span>
}
</code></pre>
<h3 id="the-jwk-way" tabindex="-1"><a class="header-anchor" href="#the-jwk-way"><span>The JWK way</span></a></h3>
<p>In a Node.js script, we can directly import the PEM key:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)

<span class="hljs-keyword">const</span> privateKey = crypto.<span class="hljs-title function_">createPrivateKey</span>({
  <span class="hljs-attr">key</span>: serviceAccount.<span class="hljs-property">private_key</span>,
  <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;pem&#x27;</span>
})
</code></pre>
<p>Which allows us to easily convert it to a JWK:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> jwk = privateKey.<span class="hljs-title function_">export</span>({ <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;jwk&#x27;</span> })
</code></pre>
<p>If we carry this JWK to the worker, for example putting the serialized
JSON in a <code>GOOGLE_APPLICATION_CREDENTIALS_JWK</code> environment variable, we
can import it like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> jwk = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(env.<span class="hljs-property">GOOGLE_APPLICATION_CREDENTIALS_JWK</span>)

<span class="hljs-keyword">const</span> algorithm = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RSASSA-PKCS1-v1_5&#x27;</span>,
  <span class="hljs-attr">hash</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;SHA-256&#x27;</span>
  }
}

<span class="hljs-keyword">const</span> extractable = <span class="hljs-literal">false</span>
<span class="hljs-keyword">const</span> keyUsages = [<span class="hljs-string">&#x27;sign&#x27;</span>]

<span class="hljs-keyword">const</span> privateKey = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">importKey</span>(<span class="hljs-string">&#x27;jwk&#x27;</span>, jwk, algorithm, extractable, keyUsages)
</code></pre>
<p>A couple points here:</p>
<ul>
<li>In the <code>algorithm</code> parameter, we specify we‚Äôre working with a
<code>RSASSA-PKCS1-v1_5</code> key, which is basically a standard RSA key.</li>
<li>We also specify a <code>hash</code> of SHA-256, which is not directly related to
the key itself, but will be useful later on when we want to sign a
JWT, since we‚Äôll use a RS256 signature (RSA signature with SHA-256).</li>
<li>We set <code>extractable</code> to <code>false</code> because we don‚Äôt want further code to
be able to dump this key. This secrity measure is especially relevant
in browsers but doesn‚Äôt hurt here either.</li>
<li>We set <code>keyUsages</code> to <code>sign</code>, allowing this key to only be used for
issuing signatures, again an extra measure tn ensure that the key is
only used for the usages that we indended.</li>
</ul>
<p>We know all this information because Google Cloud documents it
<a href="https://developers.google.com/identity/protocols/oauth2/service-account#authorizingrequests">here</a>.</p>
<p>This is great, but that new environment variable is redundant with the
RSA key that‚Äôs already in the service account JSON. Can we somehow
import the PEM key without using an intermediary JWK?</p>
<h3 id="parsing-the-pem-key-to-pkcs-8" tabindex="-1"><a class="header-anchor" href="#parsing-the-pem-key-to-pkcs-8"><span>Parsing the PEM key to PKCS #8</span></a></h3>
<p>While we can‚Äôt import directly a PEM key with SubtleCrypto, the MDN has
us covered with <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo_import">an example of parsing a PEM-encoded key</a>!
I furthered adapted this example to our Google Cloud service account key
use case.</p>
<p>First, we strip the newlines from the PEM string:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> pem = serviceAccount.<span class="hljs-property">private_key</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\n/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)
</code></pre>
<p>Then we strip the PEM header and footer markers:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> pemHeader = <span class="hljs-string">&#x27;-----BEGIN PRIVATE KEY-----&#x27;</span>
<span class="hljs-keyword">const</span> pemFooter = <span class="hljs-string">&#x27;-----END PRIVATE KEY-----&#x27;</span>

<span class="hljs-keyword">if</span> (!pem.<span class="hljs-title function_">startsWith</span>(pemHeader) || !pem.<span class="hljs-title function_">endsWith</span>(pemFooter)) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Invalid service account private key&#x27;</span>)
}

<span class="hljs-keyword">const</span> pemContents = pem.<span class="hljs-title function_">substring</span>(pemHeader.<span class="hljs-property">length</span>, pem.<span class="hljs-property">length</span> - pemFooter.<span class="hljs-property">length</span>)
</code></pre>
<p>This leaves us with a Base64-encoded string that we can decode to a
<code>Uint8Array</code>. For that I like to use the <a href="https://www.npmjs.com/package/js-base64"><code>js-base64</code></a>
package, which doesn‚Äôt have the quirks of messing with the deprecated
<code>atob</code> function (which only supports ASCII strings), and using
<a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem">workarounds</a>
like <code>decodeURIComponent(escape(atob(str)))</code>.</p>
<p>To be able to use this module, we need to make sure to bundle our code,
since Cloudflare doesn‚Äôt let us import modules like this. I like to use
<a href="https://github.com/evanw/esbuild">esbuild</a> for this, but
<a href="https://webpack.js.org/">webpack</a> is also a popular alternative.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Base64</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;js-base64&#x27;</span>

<span class="hljs-keyword">const</span> buffer = <span class="hljs-title class_">Base64</span>.<span class="hljs-title function_">toUint8Array</span>(pemContents)
</code></pre>
<p>This buffer contains effectively a binary PKCS #8 key that we can import
like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> algorithm = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RSASSA-PKCS1-v1_5&#x27;</span>,
  <span class="hljs-attr">hash</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;SHA-256&#x27;</span>
  }
}

<span class="hljs-keyword">const</span> extractable = <span class="hljs-literal">false</span>
<span class="hljs-keyword">const</span> keyUsages = [<span class="hljs-string">&#x27;sign&#x27;</span>]

<span class="hljs-keyword">const</span> privateKey = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">importKey</span>(<span class="hljs-string">&#x27;pkcs8&#x27;</span>, buffer, algorithm, extractable, keyUsages)
</code></pre>
<p>See above for explanation of <code>algorithm</code>, <code>extractable</code> and <code>keyUsage</code>
parameters.</p>
<h2 id="direct-jwt-vs-oauth" tabindex="-1"><a class="header-anchor" href="#direct-jwt-vs-oauth"><span>Direct JWT vs. OAuth</span></a></h2>
<p>Google offers us two methods to auth with its APIs in this context.
Either with a server-to-server OAuth flow, or via a self-issued JWT.
This is documented <a href="https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth">here</a>:</p>
<blockquote>
<p>With some Google APIs, you can make authorized API calls using a
signed JWT directly as a bearer token, rather than an OAuth 2.0 access
token. When this is possible, you can avoid having to make a network
request to Google‚Äôs authorization server before making an API call.</p>
<p>If the API you want to call has a service definition published in the
<a href="https://github.com/googleapis/googleapis">Google APIs GitHub repository</a>,
you can make authorized API calls using a JWT instead of an access
token.</p>
</blockquote>
<p>The direct JWT method is great because we can avoid an extra network
call to the OAuth endpoint, as well as extra error handling and retry
logic around it! And it looks like the most popular APIs support it.</p>
<p>If the API you want to call doesn‚Äôt though, don‚Äôt worry, the approach is
very similar. You still need to implement the JWT logic, but instead of
using it directly for your API calls, you use it only against Google‚Äôs
OAuth endpoint to generate an access token, which you can use in your
further API calls.</p>
<h2 id="signing-the-jwt" tabindex="-1"><a class="header-anchor" href="#signing-the-jwt"><span>Signing the JWT</span></a></h2>
<p>Now we managed to import the service account private key, we can use it
to sign a JWT. The format is documented <a href="https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth">here</a>.</p>
<p>Essentially, a JWT is made of 3 parts:</p>
<ul>
<li>A JSON header, Base64URL-encoded</li>
<li>A JSON payload, Base64URL-encoded</li>
<li>A signature, not JSON this time, but you guessed it, Base64URL-encoded</li>
</ul>
<p>What‚Äôs <a href="https://base64.guru/standards/base64url">Base64URL</a>? It‚Äôs
Base64, but slightly tweaked to be URL-safe.</p>
<p>For the Base64 business, I‚Äôll keep using the
<a href="https://www.npmjs.com/package/js-base64"><code>js-base64</code></a> module we
imported above (which conveniently supports Base64URL). Let‚Äôs start with
the header:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> header = <span class="hljs-title class_">Base64</span>.<span class="hljs-built_in">encodeURI</span>(
  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">alg</span>: <span class="hljs-string">&#x27;RS256&#x27;</span>,
    <span class="hljs-attr">typ</span>: <span class="hljs-string">&#x27;JWT&#x27;</span>,
    <span class="hljs-attr">kid</span>: serviceAccount.<span class="hljs-property">private_key_id</span>
  })
)
</code></pre>
<p>As we saw earlier, we‚Äôre going to use a RSA signature with SHA-256
(RS256), we‚Äôre effectively building a JWT, and we forward the
<code>private_key_id</code> in the <code>kid</code> field like Google wants.</p>
<p>Off to the payload. We need 5 fields:</p>
<ul>
<li><code>iss</code> and <code>sub</code>, both set to the service account email</li>
<li><code>aud</code>, the API endpoint we want to use, in our case, Pub/Sub (note the
trailing slash is important)</li>
<li><code>iat</code>, the Unix time at the moment the token was issued (now)</li>
<li><code>exp</code>, the Unix time when the JWT will expire, which can be maximum an
hour after <code>iat</code></li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> iat = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() / <span class="hljs-number">1000</span>)
<span class="hljs-keyword">const</span> exp = iat + <span class="hljs-number">3600</span>

<span class="hljs-keyword">const</span> payload = <span class="hljs-title class_">Base64</span>.<span class="hljs-built_in">encodeURI</span>(
  <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">iss</span>: serviceAccount.<span class="hljs-property">client_email</span>,
    <span class="hljs-attr">sub</span>: serviceAccount.<span class="hljs-property">client_email</span>,
    <span class="hljs-attr">aud</span>: <span class="hljs-string">&#x27;https://pubsub.googleapis.com/&#x27;</span>,
    exp,
    iat
  })
)
</code></pre>
<p>Next, we can compute the signature. Remember we still have our
<code>privateKey</code> variable from earlier:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> textEncoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>()
<span class="hljs-keyword">const</span> inputArrayBuffer = textEncoder.<span class="hljs-title function_">encode</span>(<span class="hljs-string">`<span class="hljs-subst">${header}</span>.<span class="hljs-subst">${payload}</span>`</span>)

<span class="hljs-keyword">const</span> outputArrayBuffer = <span class="hljs-keyword">await</span> crypto.<span class="hljs-property">subtle</span>.<span class="hljs-title function_">sign</span>(
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RSASSA-PKCS1-v1_5&#x27;</span> },
  privateKey,
  inputArrayBuffer
)

<span class="hljs-keyword">const</span> signature = <span class="hljs-title class_">Base64</span>.<span class="hljs-title function_">fromUint8Array</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(outputArrayBuffer), <span class="hljs-literal">true</span>)
</code></pre>
<p>A bit more complexity here. <code>crypto.subtle.sign</code> expects an
<code>ArrayBuffer</code> but we have a string, so <a href="https://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers">we use a <code>TextEncoder</code> to convert it</a>.
Then, we get the signature as an <code>ArrayBuffer</code>, but in order to encode
it, <code>js-base64</code> expects an <code>Uint8Array</code>, so we do the conversion.
Finally, we pass <code>true</code> as second parameter to <code>Base64.fromUint8Array</code>
because we want a Base64URL representation.</p>
<p>We now have all we need to assemble our JWT. The 3 components of the
token are separated by the <code>.</code> character:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> token = <span class="hljs-string">`<span class="hljs-subst">${header}</span>.<span class="hljs-subst">${payload}</span>.<span class="hljs-subst">${signature}</span>`</span>
</code></pre>
<h2 id="calling-the-google-cloud-api" tabindex="-1"><a class="header-anchor" href="#calling-the-google-cloud-api"><span>Calling the Google Cloud API</span></a></h2>
<p>We can now use our fresh token to issue <code>fetch</code> requests to the Google
Cloud API!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
  <span class="hljs-string">`https://pubsub.googleapis.com/v1/projects/.../topics/...:publish`</span>,
  {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,
      <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    },
    body
  }
)
</code></pre>
<p>There‚Äôs still a bit more work to do, especially about dealing with
possible HTTP errors, and handling the token refresh logic. I‚Äôll leave
that as an exercise to the reader.</p>
<p>Finally, if you want to use an endpoint that doesn‚Äôt support
<a href="https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth">direct JWT</a>
like this, and you need to get an OAuth token instead, you can use
<code>https://oauth2.googleapis.com/token</code> in the <code>aud</code> field instead, add a
<code>scope</code> field to the JWT, and call that OAuth token endpoint to get an
access token. Again, all the details are <a href="https://developers.google.com/identity/protocols/oauth2/service-account#authorizingrequests">here</a>.</p>
<h2 id="wrapping-up" tabindex="-1"><a class="header-anchor" href="#wrapping-up"><span>Wrapping up</span></a></h2>
<p>And just like this, we managed to call Google Cloud APIs from Cloudflare
Workers! This got a bit technical because there‚Äôs no Cloudflare-ready
SDK for it, but this was a great opportunity to learn how Google Cloud
authentication normally works with service accounts, and get a better
idea of the cryptography behind it.</p>
<p>I hope you learnt something! And if you like to work with Cloudflare and
Google Cloud, <a href="https://hookdeck.com/jobs/backend-devops-sre">we‚Äôre hiring</a>,
and that‚Äôs what we do‚Ä¶ every day!</p>
<section class="post-footer">
  <h3>Want to leave a comment?</h3>
  <p>
    Join the discussion on <a href="https://x.com/Hookdeck/status/1496535899257118720">X</a> or send me an <a href="mailto:val@codejam.info">email</a>! üíå<br>
    This post helped you? <a href="https://ko-fi.com/funkyval">Buy me a coffee</a>! üçª
  </p>
</section>
  </div>
  <footer>
    <div class="footer-inner">
      <figure>
        <a href="/val.html">
          <img alt="The author (Val) in front of a mountain" src="/img/profile.jpg">
        </a>
      </figure>
      <div class="footer-content">
        <p>
          Made with üß° by <a href="/val.html">Val</a>.
          Generated from a <abbr title="Pull requests welcome!"><a href="https://github.com/valeriangalliat/blog/tree/master/2022/02/how-to-call-google-cloud-apis-from-cloudflare-workers.md">public repository</a></abbr>.
        </p>
        <ul class="social">
          <li>
            <a href="https://x.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 24 24">
                <title>X</title>
                <use href="/img/icons/x.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://github.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 24 24">
                <title>GitHub</title>
                <use href="/img/icons/github.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.instagram.com/funkyval_/">
              <svg width="16" height="16" viewBox="0 0 24 24">
                <title>Instagram</title>
                <use href="/img/icons/instagram.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.youtube.com/@FunkyVal">
              <svg width="16" height="16" viewBox="0 0 24 24">
                <title>YouTube</title>
                <use href="/img/icons/youtube.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://ko-fi.com/funkyval">
              <svg width="16" height="16" viewBox="0 0 24 24">
                <title>Buy me a coffee!</title>
                <use href="/img/icons/kofi.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="/feed.xml">
              <svg width="16" height="16" viewBox="0 0 24 24">
                <title>RSS</title>
                <use href="/img/icons/rss.svg#icon"></use>
              </svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </footer>
  <script src="/js/emojicon.js"></script>
  <script src="/js/main-20230317.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Google Cloud Functions with a static IP: a guide to high throughput NAT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script>document.documentElement.classList.add(localStorage.theme || ((matchMedia && matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light'))</script>
  <link rel="stylesheet" href="/css/normalize.css">
  <link rel="stylesheet" href="/css/github-20220617.css">
  <link rel="stylesheet" href="/css/main-20250622.css">
  <link rel="icon" href="/favicon.ico" data-emoji="üèïÔ∏è">
  <link rel="alternate" href="/feed.xml" type="application/atom+xml" title="CodeJam">
  <meta property="og:title" content="Google Cloud Functions with a static IP: a guide to high throughput NAT">
  <meta property="og:description" content="One day or another, you‚Äôre gonna encounter a firewall with an IP whitelist. It only accepts connections from specific IP addresses that were explicitly allowed.">
  <meta property="og:image" content="https://www.codejam.info/img/profile.jpg">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@valeriangalliat">
  <meta name="twitter:creator" content="@valeriangalliat">
</head>
<body class="post">
  <nav>
    <ul>
      <li><a href="/">Home</a></li>
      <li><a href="/val.html">About</a></li>
      <li><a href="/now.html">Now</a></li>
      <li class="pull"><button title="Toggle theme" class="change-color-theme">üåù</button></li>
    </ul>
  </nav>
  <header>
    <div class="header-inner">
      <div class="content">
<h1>Google Cloud Functions with a static IP: a guide to high throughput NAT</h1>
<p class="date">March 16, 2023</p>
      </div>
    </div>
  </header>
  <div class="content">
<p>One day or another, you‚Äôre gonna encounter a firewall with an IP
whitelist. It only accepts connections from specific IP addresses that
were explicitly allowed.</p>
<p>If you have a cloud, serverless and/or autoscaling infrastructure, new
resources are provisioned and deprovisioned automatically to accommodate
your load, and public IPs are dynamically allocated when needed. <strong>You
can‚Äôt predict what public IP address are your requests going to be sent
from</strong>.</p>
<p>This is a problem I‚Äôve needed to solve in virtually every company I‚Äôve
worked with in my career.</p>
<p>The solutions may vary depending on the technologies you use, and your
load patterns. For example, a simple proxy server (TCP, HTTP or SOCKS,
maybe load balanced between a few instances) might go a long way before
you need to resort to more complex solutions.</p>
<p>In this blog post I‚Äôll focus on Google Cloud, and in particular Cloud
Functions, but you might find it useful if you have the same use case
with Cloud Run or Kubernetes, or just need to fine tune a Cloud NAT in
general.</p>
<div class="note">
<p><strong>Note:</strong> this also applies to Firebase Functions, since they‚Äôre
implemented as Cloud Functions.</p>
</div>
<h2 id="building-blocks" tabindex="-1"><a class="header-anchor" href="#building-blocks"><span>Building blocks</span></a></h2>
<p>If the proxy server approach doesn‚Äôt meet your requirements, or you just
want a more ‚Äúcloud native‚Äù solution, you‚Äôll need two pieces of
infrastructure in order to route your Cloud Functions or Cloud Run
containers traffic through static IPs: a <strong>VPC connector</strong>,
and a <strong>Cloud NAT</strong>.</p>
<p>If you run on Kubernetes, you only need the Cloud NAT.</p>
<h2 id="vpc-connector" tabindex="-1"><a class="header-anchor" href="#vpc-connector"><span>VPC connector</span></a></h2>
<p>The VPC connector, also known as <a href="https://cloud.google.com/vpc/docs/configure-serverless-vpc-access">Serverless VPC Access connector</a>,
is a piece of Google Cloud infrastructure that lets you route the
traffic of Cloud Functions and Cloud Run containers to your <abbr title="Virtual private cloud">VPC</abbr>.</p>
<p>This is useful if you want them to access private resources, or in our
case, if you want them to access the internet through static IPs.</p>
<p>The VPC connector is backed by 2 to 10 plain old Compute Engine VMs,
that you can chose from a limited subset of instance sizes (<code>f1-micro</code>,
<code>e2-micro</code> and <code>e2-standard-4</code>). Not far from the naive proxy approach,
but it has to its advantage that those VMs are managed by Google, and
that they have a first-class integration with Cloud Functions and Cloud
Run.</p>
<p>Those instances live in a <code>/28</code> subnet that you allocate for them on
your VPC. <code>/28</code> gives you <a href="https://cloud.google.com/vpc/docs/serverless-vpc-access#ip_address_ranges">14 usable addresses</a>
which is sufficient for the 10 instances upper limit.</p>
<p>A few more things to note:</p>
<ul>
<li>You configure a minimum and maximum number of instances, between 2 and 10.</li>
<li>The connector starts with the minimum number of instances, and will
add more up to the maximum number if your traffic requires it.</li>
<li>After scaling up, the connector doesn‚Äôt scale down and you‚Äôll have to
recreate it if you want to lower the instances count. üôà</li>
</ul>
<p>Useful links:</p>
<ul>
<li><a href="https://cloud.google.com/vpc/docs/serverless-vpc-access">Serverless VPC Access</a></li>
<li><a href="https://cloud.google.com/vpc/docs/configure-serverless-vpc-access">Configure Serverless VPC Access</a></li>
</ul>
<h2 id="cloud-nat" tabindex="-1"><a class="header-anchor" href="#cloud-nat"><span>Cloud NAT</span></a></h2>
<p>Cloud NAT is the second piece of the puzzle. It allows you to perform
network address translation (NAT) on Compute Engine VMs that don‚Äôt have
an external IP address.</p>
<p>Even though Cloud NAT depends on a Cloud Router, <a href="https://serverfault.com/q/1078625">it only uses it</a>
for configuring <a href="https://cloudplatform.googleblog.com/2014/04/enter-andromeda-zone-google-cloud-platforms-latest-networking-stack.html">Google Cloud‚Äôs networking stack</a>
but it‚Äôs not involved at the data level: it doesn‚Äôt add an extra hop and
potential bottleneck in your network topology!</p>
<p>In other words, you can expect an identical network bandwidth and
performance with Cloud NAT as if your VMs directly had public IPs, as
long as it‚Äôs appropriately configured for your situation (more on that
later).</p>
<p>Cloud NAT can be configured to dynamically allocate IP addresses as
needed, or use a static pool of IP addresses, which is going to be
useful for us.</p>
<p>In our case, Cloud NAT works hand in hand with the VPC connector VMs,
not only to provide them with internet access, but to do so using static
IPs if we configure the NAT that way!</p>
<p>Useful links:</p>
<ul>
<li><a href="https://cloud.google.com/nat/docs/overview">Cloud NAT overview</a></li>
<li><a href="https://medium.com/bluekiri/high-availability-nat-gateway-at-google-cloud-platform-with-cloud-nat-8a792b1c4cc4">High availability NAT gateway at Google Cloud Platform with Cloud NAT</a></li>
</ul>
<h2 id="configuring-them-together" tabindex="-1"><a class="header-anchor" href="#configuring-them-together"><span>Configuring them together</span></a></h2>
<p>I‚Äôll skim over this part as there‚Äôs already decent coverage online:</p>
<ul>
<li><a href="https://dev.to/alvardev/gcp-cloud-functions-with-a-static-ip-3fe9">GCP Cloud Functions with a static IP</a></li>
<li><a href="https://gist.github.com/brokeyourbike/ee7c5ede900da6f31ced9fe587e0c706">Cloud Functions static outbound IP address</a></li>
<li><a href="https://stackoverflow.com/q/38811882">Possible to get static IP address for Google Cloud Functions?</a></li>
<li><a href="https://cloud.google.com/nat/docs/set-up-manage-network-address-translation">Set up and manage network address translation with Cloud NAT</a></li>
</ul>
<p>To add my own contribution, I‚Äôll share a <a href="https://www.pulumi.com/">Pulumi</a>
example to provision everything you need to get a static IP on your
Cloud Functions. It‚Äôll get you in the same place as the tutorials above.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> gcp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@pulumi/gcp&#x27;</span>)

<span class="hljs-keyword">const</span> subnet = <span class="hljs-keyword">new</span> gcp.<span class="hljs-property">compute</span>.<span class="hljs-title class_">Subnetwork</span>(<span class="hljs-string">&#x27;subnet&#x27;</span>, {
  <span class="hljs-attr">network</span>: <span class="hljs-string">&#x27;default&#x27;</span>,
   <span class="hljs-comment">// Arbitrary range that doesn&#x27;t conflict with other subnets in your VPC</span>
  <span class="hljs-attr">ipCidrRange</span>: <span class="hljs-string">&#x27;10.8.0.0/28&#x27;</span>
})

<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> gcp.<span class="hljs-property">compute</span>.<span class="hljs-title class_">Router</span>(<span class="hljs-string">&#x27;router&#x27;</span>, {
  <span class="hljs-attr">network</span>: <span class="hljs-string">&#x27;default&#x27;</span>
})

<span class="hljs-keyword">const</span> ip1 = <span class="hljs-keyword">new</span> gcp.<span class="hljs-property">compute</span>.<span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;ip-1&#x27;</span>, {})
<span class="hljs-keyword">const</span> ip2 = <span class="hljs-keyword">new</span> gcp.<span class="hljs-property">compute</span>.<span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;ip-2&#x27;</span>, {})

<span class="hljs-keyword">new</span> gcp.<span class="hljs-property">compute</span>.<span class="hljs-title class_">RouterNat</span>(<span class="hljs-string">&#x27;nat&#x27;</span>, {
  <span class="hljs-attr">router</span>: router.<span class="hljs-property">name</span>,
  <span class="hljs-attr">region</span>: router.<span class="hljs-property">region</span>,

  <span class="hljs-attr">natIpAllocateOption</span>: <span class="hljs-string">&#x27;MANUAL_ONLY&#x27;</span>,
  <span class="hljs-attr">natIps</span>: [ip1.<span class="hljs-property">selfLink</span>, ip2.<span class="hljs-property">selfLink</span>],

  <span class="hljs-attr">sourceSubnetworkIpRangesToNat</span>: <span class="hljs-string">&#x27;LIST_OF_SUBNETWORKS&#x27;</span>,
  <span class="hljs-attr">subnetworks</span>: [
    {
      <span class="hljs-attr">name</span>: subnet.<span class="hljs-property">id</span>,
      <span class="hljs-attr">sourceIpRangesToNats</span>: [<span class="hljs-string">&#x27;ALL_IP_RANGES&#x27;</span>]
    }
  ],

  <span class="hljs-comment">// If not specified, Pulumi enables endpoint-independent mapping by default,</span>
  <span class="hljs-comment">// even though it&#x27;s not enabled by default when using the Google Cloud</span>
  <span class="hljs-comment">// console.</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// To be in the same state as if we used the console, we explicitly</span>
  <span class="hljs-comment">// have to disable it here.</span>
  <span class="hljs-attr">enableEndpointIndependentMapping</span>: <span class="hljs-literal">false</span>

  <span class="hljs-comment">// More things to go here for optimal performance, see below</span>
})

<span class="hljs-keyword">new</span> gcp.<span class="hljs-property">vpcaccess</span>.<span class="hljs-title class_">Connector</span>(<span class="hljs-string">&#x27;connector&#x27;</span>, {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;connector&#x27;</span>,
  <span class="hljs-attr">subnet</span>: {
    <span class="hljs-attr">name</span>: subnet.<span class="hljs-property">name</span>
  }
})
</code></pre>
<p>What this code does:</p>
<ol>
<li>Provision a <code>/28</code> subnet that is going to be used for the VPC
connector VMs, and that we‚Äôll attach the NAT to.</li>
<li>Create the Cloud Router necessary for the NAT to do its
configurational magic.</li>
<li>Allocate 2 static public IP addresses.</li>
<li>Create the Cloud NAT in manual mode with the IPs we just created, and
attach it to the VPC connector subnet.</li>
<li>Create the VPC connector in the subnet we prepared for it.</li>
</ol>
<p>Finally you can configure your Cloud Functions, Firebase Functions or
Cloud Run containers to use that VPC connector for all its traffic. In
the case of a Firebase Function, it looks like this:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> functions = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;firebase-functions&#x27;</span>)

functions.<span class="hljs-title function_">runWith</span>({
  <span class="hljs-attr">vpcConnector</span>: <span class="hljs-string">&#x27;connector&#x27;</span>,
  <span class="hljs-attr">vpcConnectorEgressSettings</span>: <span class="hljs-string">&#x27;ALL_TRAFFIC&#x27;</span>
})
  <span class="hljs-comment">// Your actual function, for example</span>
  .<span class="hljs-property">https</span>.<span class="hljs-title function_">onRequest</span>(<span class="hljs-title function_">async</span> (req, res) =&gt; {
    response.<span class="hljs-title function_">json</span>(<span class="hljs-title function_">await</span> (<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.ipify.org?format=json&#x27;</span>)).<span class="hljs-title function_">json</span>())
  })
</code></pre>
<p>And ta-da, you get static IPs! üéâ</p>
<p>Everything seems to be working smoothly when you perform basic
connectivity testing (i.e. making a few requests to <a href="https://api.ipify.org"><code>api.ipify.org</code></a>),
so you pat yourself on the back ‚Äúnice, it wasn‚Äôt that bad after all‚Äù and
you go grab a beer.</p>
<p>Did you think you were done? Wait. We‚Äôre just getting started.</p>
<h2 id="when-the-trouble-start" tabindex="-1"><a class="header-anchor" href="#when-the-trouble-start"><span>When the trouble start</span></a></h2>
<p>So you happily go on and deploy your Cloud NAT and VPC Connector. To
your staging environment, obviously, right? Right?</p>
<figure class="center">
  <img alt="Meme about deploying to staging" src="../../img/2023/03/to-staging-right.jpg">
</figure>
<p>But if you have some kind of traffic, you quickly notice something
wrong.</p>
<p>Your Cloud Functions‚Äô <strong>execution time</strong> is much higher than
usual (up to minutes instead of milliseconds), and as a side effect of
that, your <strong>instance count</strong> is likely higher than normal. On the VPC
Connector side, everything looks good. But on the Cloud NAT, you notice
a non-zero <strong>dropped sent packets rate</strong>, with <code>OUT_OF_RESOURCES</code> as a
reason.</p>
<p>Maybe you also have a non-zero <strong>dropped received packets rate</strong> but
that is probably not the concern here (<a href="#what-about-dropped-received-packets-rate">more on that later</a>).</p>
<p>So what is going on? <a href="https://cloud.google.com/nat/docs/monitoring#gateway_filtering_dimensions">The docs</a>
tell us that Cloud NAT is running out of NAT IP addresses or ports.</p>
<div class="note">
<p><strong>Note:</strong> if you used Pulumi (<a href="https://github.com/hashicorp/terraform-provider-google/issues/10609">or Terraform</a>)
without explicitly disabling endpoint-independent mapping, you might
have accidentally turned on <a href="https://cloud.google.com/nat/docs/ports-and-addresses#ports-reuse-endpoints">endpoint-independent mapping (EIM)</a>,
which wouldn‚Äôt have been on by default if you used the GCP console.</p>
<p>If you see dropped packets with reason <code>ENDPOINT_INDEPENDENT_CONFLICT</code>,
and you didn‚Äôt intend to enable endpoint-independent mapping, this is
your problem here. You probably want to disable it, or even to enable
<em>dynamic port allocation</em>.</p>
<p>In case you <em>do</em> need endpoint-independent mapping, <a href="https://cloud.google.com/nat/docs/troubleshooting#endpoint-independent-conflict">this section of the docs</a>
can help you troubleshoot this.</p>
</div>
<h2 id="fixing-nat-out-of-resources" tabindex="-1"><a class="header-anchor" href="#fixing-nat-out-of-resources"><span>Fixing NAT out of resources</span></a></h2>
<p>Let‚Äôs say you assigned 2 NAT IPs. Each IP gives you
<a href="https://cloud.google.com/nat/docs/ports-and-addresses#ports">64,512</a>
ports to work with (65,536 minus the 1024 privileged ports). So we‚Äôre
working with a total of 129,024 ports available for NAT at a time.</p>
<p>If this looks a bit tight for your current traffic and network patterns,
there you go, you need to add more IPs.</p>
<p>But if you estimate that is is reasonable (or even <em>way, way enough</em>)
for your expected traffic, adding more IPs will likely not solve the
problem.</p>
<p>In our case with the <em>default</em> Cloud NAT configuration, it should be in
<a href="https://cloud.google.com/nat/docs/ports-and-addresses#static-port">static port allocation mode</a>,
aka the state it‚Äôs in if you don‚Äôt check ‚Äúdynamic port allocation‚Äù in
the <strong>advanced configurations</strong> part (hidden by default).</p>
<figure class="center">
  <img alt="Default Cloud NAT port allocation settings" srcset="../../img/2023/03/cloud-nat-port-allocation.png 2x">
</figure>
<p>What this reveals is one key piece of information. <strong>Our Cloud NAT
defaults to static port allocation with 64 ports per VM.</strong></p>
<p>The copy in this UI is misleading, because while it reads 64 ‚Äúminimum
ports per VM instance‚Äù, it is actually both a minimum <em>and</em> a maximum
(well, it‚Äôs <em>static</em>), which is why the ‚Äúmaximum ports‚Äù input is
disabled.</p>
<p><strong>So let‚Äôs say you configured your VPC Connector to use 2 VMs, this means
you‚Äôre artificially limiting your NAT to use a most 128 ports used at a
time!!</strong> (Out of your 129,024 available ports if you have 2 IPs. üòÖ)</p>
<p>No wonder when all the traffic of your Cloud Functions go through those
two poor VPC Connector VMs, you end up seeing huge network latency and
dropped packets.</p>
<div class="note">
<p><strong>Note:</strong> the number you care about here is really the number of VMs you
configured on the VPC Connector. You may have a much higher <em>instances
count</em> on your Cloud Functions side, but since their traffic has to go
through the VPC Connector instances first, it‚Äôs really this one that
matters.</p>
</div>
<p>Once we understand that, the fix becomes obvious: <strong>increase the number
of ports per VM</strong>.</p>
<p>Since in our example we have 2 VPC Connector VMs and 2 IP addresses,
assuming we use the Cloud NAT only for those, we could in theory assign
up to 65,536 ports (all of an IP‚Äôs ports) per VM!</p>
<p>Obviously adjust this number based on the maximum number of VMs you can
have relative to how many IPs you allocated.</p>
<p>Realistically, if you want to keep some headroom for adding more VPC
Connector VMs without adding more IPs in the future, you need to pick a
lower number like 4,096, 8,192, 16,384 or 32,768, especially if that‚Äôs
enough for your current needs.</p>
<p>The takeaway from is that the default Cloud NAT configuration is really
not adapted to be used with a VPC Connector, and we‚Äôre required to tune
the settings for proper network performance. It‚Äôs probably a decent
default for other use cases, but <em>definitely</em> not this one.</p>
<h2 id="going-further-with-dynamic-port-allocation" tabindex="-1"><a class="header-anchor" href="#going-further-with-dynamic-port-allocation"><span>Going further with dynamic port allocation</span></a></h2>
<p>Increasing the static number of ports per VM should have helped quite a
bit with the latency and dropped packets, but we can do better.</p>
<p>If we enable <a href="https://cloud.google.com/nat/docs/ports-and-addresses#dynamic-port">dynamic port allocation</a>,
this will allow Cloud NAT to allocate even more ports to a given VM if
needed. It can use any number of ports between the min/max range you
configure, up to a maximum of 65,536 ports (a full IP).</p>
<p>An important thing to keep in mind with dynamic port allocation is that
when a VM uses all its pre-allocated ports and reaches the point where
it needs to allocate more more ports dynamically, <strong>this is not
instantaneous</strong>.</p>
<p>The symptoms of that would be, again, dropped packets and increased
latency while the ports are being allocated.</p>
<p>In our scenario, this would be very obvious if we used dynamic port
allocation with its default minimum ports per VM of 32 (when our load
needs orders of magnitude more ports than that).</p>
<p><strong>So we can‚Äôt rely solely on dynamic port allocation to save our day. We
do still need to configure a sensible minimum ports per VM <em>that matches
our expected needs</em>.</strong></p>
<p>Concretely, if we have 2 to 3 VPC Connector VMs, 2 NAT IPs, and the NAT
is solely used by the VPC Connector, using a dynamic port allocation
with a minimum ports per VM of 16,384 would be a good match that lives
us some headroom for adding a few more VMs without needing extra IPs.</p>
<h2 id="going-even-further-with-tcp-settings" tabindex="-1"><a class="header-anchor" href="#going-even-further-with-tcp-settings"><span>Going even further with TCP settings</span></a></h2>
<p>The <strong>advanced configurations</strong> of Cloud NAT also gives us control over
various protocol timeouts. Here are the defaults:</p>
<figure class="center">
  <img alt="Default Cloud NAT timeouts settings" srcset="../../img/2023/03/cloud-nat-timeouts.png 2x">
</figure>
<p>Here we‚Äôll focus on the TCP settings. Here‚Äôs a more detailed description
of those from <a href="https://cloud.google.com/nat/docs/overview#specs-timeouts">the spec</a>:</p>
<ul>
<li><strong>TCP established connection idle timeout:</strong> specifies the time that a
connection is idle before the Cloud NAT mappings are removed.</li>
<li><strong>TCP transitory connection idle timeout:</strong> specifies the time that
TCP connections can remain in the <a href="https://en.wikipedia.org/wiki/TCP_half-open">half-open state</a>
before the Cloud NAT mappings can be deleted.</li>
<li><strong>TCP time wait:</strong> specifies the time that a
fully closed TCP connection is retained in the Cloud NAT mappings
after the connection expires.</li>
</ul>
<p>I‚Äôm not too concerned about half-open TCP connections, and keeping them
around for 30 seconds sounds like a reasonable value in the first place,
so we‚Äôll leave the <strong>transitory idle timeout</strong> alone.</p>
<p>For <strong>established idle timeout</strong> and <strong>TCP time wait</strong> though,
respective values of <strong>TWENTY MINUTES</strong> and 2 minutes may be more
problematic.</p>
<p>Those defaults are probably sensible when you have <em>actual</em> VMs
directly connecting through the NAT, but with the dynamic and
‚Äúserverless‚Äù nature of Cloud Functions, keeping idle and especially
closed connections around for that long is no good.</p>
<p><strong>Matching those with the value of your Cloud Functions request timeout
would make more sense</strong>, which may be as low as 60 or 30 seconds (or
even lower). Once a function gets killed because it exceeded its
timeout, there‚Äôs no point in keeping the TCP connections it opened (and
maybe failed to close) for any longer, especially not 20 minutes!</p>
<p>In my case, lowering those timeouts to 30 seconds had a noticeable
difference in the NAT <strong>open connections</strong> and port <strong>usage metric</strong>
(they got cut by half!).</p>
<h2 id="applying-this-to-our-pulumi-example" tabindex="-1"><a class="header-anchor" href="#applying-this-to-our-pulumi-example"><span>Applying this to our Pulumi example</span></a></h2>
<p>After learning all this, we can go back to our initial <a href="#configuring-them-together">Pulumi example</a>
and apply those optimizations by adding the following to our <code>RouterNat</code>
configuration. <strong>Keep in mind this is tuned for 2 (min) to 3 (max) VPC
Connector VMs that are the <em>sole</em> VMs to use a Cloud NAT with 2 static IPs.</strong>
Tweak appropriately.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">new</span> gcp.<span class="hljs-property">compute</span>.<span class="hljs-title class_">RouterNat</span>(<span class="hljs-string">&#x27;nat&#x27;</span>, {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-attr">enableDynamicPortAllocation</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">minPortsPerVm</span>: <span class="hljs-number">16384</span>,
  <span class="hljs-attr">maxPortsPerVm</span>: <span class="hljs-number">65536</span>,
  <span class="hljs-attr">tcpEstablishedIdleTimeoutSec</span>: <span class="hljs-number">60</span>,
  <span class="hljs-attr">tcpTimeWaitTimeoutSec</span>: <span class="hljs-number">60</span>
})
</code></pre>
<h2 id="what-about-dropped-received-packets-rate" tabindex="-1"><a class="header-anchor" href="#what-about-dropped-received-packets-rate"><span>What about dropped received packets rate?</span></a></h2>
<p>After all this, we‚Äôre in a pretty good spot for our Cloud Functions to
go through Cloud NAT static IPs with optimal performance.</p>
<p>Yet, you might notice that your <a href="https://stackoverflow.com/q/72620834/4324668">dropped received packets</a>
metric in Cloud NAT is non-zero, and that may concern you.</p>
<p>My advice for you will be to look at the proportion of dropped received
packets compared to your total received packets.</p>
<p>While the Cloud NAT metrics tab shows you the dropped received packets
rate, you don‚Äôt get the total received packets rate there. You‚Äôll have
to go to GCP metrics explorer and look at <code>received_packets_count</code>.</p>
<p>If your dropped received packets rate is especially low compared to the
total received packets you‚Äôre processing (e.g. 0.01%), and you notice no
negative effects on your app (latency, errors or whatnot), you‚Äôre
probably fine. After all, those packets are packets that Cloud NAT could
not translate, which may include invalid or unauthorized traffic.</p>
<p>However if it‚Äôs affecting a non-negligible part of your traffic, and
if you‚Äôre noticing a high latency or network error rate, you definitely
need to address it. This will widely vary based on your specific context
and network patterns, but as a blind shot, if you underestimated how
long your Cloud Functions can be alive and you <a href="#going-even-further-with-tcp-settings">lowered the TCP timeouts</a>
too much, there‚Äôs probably some tuning to be done around there.</p>
<h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2>
<p>If you made it here, congrats! This article was pretty dense, and we
covered a number of fairly complex topics. I hope you learnt everything
you needed in order to have a successful Cloud NAT configuration for
your serverless (or Kubernetes) environment.</p>
<p>If I made mistakes in this post, or if you found something of value that
would be worth adding there, as usual, <a href="/val.html#contact">let me know</a>
and I‚Äôll be happy to make updates!</p>
<section class="post-footer">
  <h3>Want to leave a comment?</h3>
  <p>
    Join the discussion on <a href="https://twitter.com/valeriangalliat/status/1636458334340390941">Twitter</a> or send me an <a href="mailto:val@codejam.info">email</a>! üíå<br>
    This post helped you? <a href="https://ko-fi.com/funkyval">Buy me a coffee</a>! üçª
  </p>
</section>
  </div>
  <footer>
    <div class="footer-inner">
      <figure>
        <a href="/val.html">
          <img alt="The author (Val) in front of a mountain" src="/img/profile.jpg">
        </a>
      </figure>
      <div class="footer-content">
        <p>
          Made with üß° by <a href="/val.html">Val</a>.
          Generated from a <abbr title="Pull requests welcome!"><a href="https://github.com/valeriangalliat/blog/tree/master/2023/03/cloud-functions-static-ip-nat.md">public repository</a></abbr>.
        </p>
        <ul class="social">
          <li>
            <a href="https://twitter.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Twitter</title>
                <use href="/img/icons/407-twitter.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://github.com/valeriangalliat">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>GitHub</title>
                <use href="/img/icons/433-github.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.instagram.com/funkyval_/">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Instagram</title>
                <use href="/img/icons/403-instagram.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://www.youtube.com/@FunkyVal">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>YouTube</title>
                <use href="/img/icons/414-youtube.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="https://ko-fi.com/funkyval">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>Buy me a coffee!</title>
                <use href="/img/icons/219-heart.svg#icon"></use>
              </svg>
            </a>
          </li>
          <li>
            <a href="/feed.xml">
              <svg width="16" height="16" viewBox="0 0 16 16">
                <title>RSS</title>
                <use href="/img/icons/412-rss.svg#icon"></use>
              </svg>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </footer>
  <script src="/js/emojicon.js"></script>
  <script src="/js/main-20230317.js"></script>
</body>
</html>
